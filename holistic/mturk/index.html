<!DOCTYPE html>
<meta charset="utf-8">
<style type="text/css">
	.node {
    cursor: pointer;
  }
  .overlay{
      background-color:white;
  }
  .node circle {
    fill: #fff;
    stroke: steelblue;
    stroke-width: 1.5px;
  }
  .node text {
    font-size:10px;
    font-family:sans-serif;
  }
  .link {
    fill: none;
    stroke: #ccc;
    stroke-width: 1.5px;
  }
  .additionalParentLink {
    fill: none;
    stroke: blue;
    stroke-width: 1.5px;
  }
  .templink {
    fill: none;
    stroke: red;
    stroke-width: 3px;
  }
  .ghostCircle.show{
      display:block;
  }
  .ghostCircle, .activeDrag .ghostCircle{
       display: none;
  }

	.trialDiv {
		display: none;
	}

	#responseButton {
		display: none;
	}

	#tempStorage {
		display: none;
	}

	#radiowrapper {
		display: none;
	}

	#numberwrapper {
		display: none;
	}

	#trialcounter {
		display: none;
	}


	g.am-axis text {
    font-size: 12px;
  }

	.background {
	  fill: #eee;
	}

	line {
	  stroke: #fff;
	}

	text.active {
	  fill: orange;
	}

	.introImages {
		width:350px;
		height:350px;
		float: left;
		border:0;
	}

	.domlabel {
		display: none;
	}

</style>
<body>
	<div id="instructions"><b>Instructions for the experiment.</b>
		<p>In this study, you will be asked to complete certain number of visual tasks using two visual representations of the same information: Matrix and combined Tree.</p>
		<div style="float:left"> <p><b>Matrix</b></p>
			<img src="matrix_intro.png" alt="matrix" class="introImages">
		</div>
		<div style="float:left; margin-left:150px"><p><b>Tree</b></p>
			<img src="tree_intro.png" alt="tree" class="introImages">
		</div>
		<p style="clear:both"></p>
		</br>
		<p style="clear:both">Presented in visualisations is a breakdown of the knowledge that surrounds the development of a basic autonomous robot. This knowledge is broken down into three main domains:
			<ul>
				<li>REQUIREMENTS - represent requirements from customers, engineers and other stakeholders</li>
				<li>FUNCTIONS - represent functions of the robot that help to accomplish those requirements</li>
				<li>STRUCTURE - represent physical modules and parts of the robot</li>
			</ul>
			</p>
		<p style="clear:both"></p>
		</br>
		<p style="clear:both">Both visualisations have highlighting features enabled:</p>
		<ul>
			<li>When using Tree visualisation, you can hover the mouse on CIRCLE NODES and see which entities are connected to the selected nodes.</li>
			<li>When using Matrix visualisation, you can hover the mouse on TEXT ON THE LEFT SIDE OF THE MATRIX and see which entities are connected to the selected entities.</li>
		</ul>
		<p></p>
		<p></p>
		<p>Depending on the task type, you will be asked either
			<ul>
			  <li>to select one entity (node). To do this, just click on the desired entity, it will change color to RED. If you want to select another entity, unselect RED entity and select new one.</li>
			  <li>to select multiple entities (nodes). To do this, click on ALL the desired entities, so that they change their color to RED. If you want to select another entity, unselect RED entity and select new one.</li>
			  <li>to enter a number</li>
			  <li>to answer either Yes or No</li>
			</ul>
		</p>
		<a href="#" id="startExperiment"><b>I understood, proceed to the experiment</b></a>
		</br></br></br></br>
	</div>




		<div id="tempStorage">
			<p>tempStorage </p>
		</div>

		<p id="trialcounter">Question #1</p>
		<button type="button" id="responseButton" style = "margin-bottom:20px">Submit current answer</button>

		<div id="radiowrapper">
		  <label for="yes_no_radio">Please select answer below:</label>
			<p>
				<input type="radio" name="yes_no">Yes</input>
			</p>
			<p>
				<input type="radio" name="yes_no" checked>No</input>
			</p>
		</div>

		<div id="numberwrapper">
			<input type="number" name="quantity" min="0" max="70" />
		</div>

		<text class="domlabel">REQUIREMENTS
		</text>
		<text class="domlabel">FUNCTIONAL
		</text>
		<text class="domlabel">STRUCTURAL
		</text>

		<button type="button" id="responseButton">Response Button</button>

		<div id="trial0" class="trialDiv">
			<p>Placeholder</p>
    	<div id="tree-container0"></div>
		</div>

</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.0.0/d3.min.js"></script>
<script src="d3.layout.adjacencyMatrix.js" type="text/JavaScript"></script>
<script>

var json = {
	"nodes": [
		{ "name": "path detection", "level": 3, "domain": "requirements" },
		{ "name": "steering", "level": 3, "domain": "requirements" },
		{ "name": "obstacle avoidance", "level": 3, "domain": "requirements" },
		{ "name": "enable communication between subsystems", "level": 3, "domain": "requirements" },
		{ "name": "weight detection", "level": 3, "domain": "requirements" },
		{ "name": "thermal insulation", "level": 3, "domain": "requirements" },
		{ "name": "damping", "level": 3, "domain": "requirements" },
		{ "name": "compact sizing", "level": 3, "domain": "requirements" },
		{ "name": "delivery in 10 minutes", "level": 2, "domain": "requirements" },
		{ "name": "distance of 6 km", "level": 2, "domain": "requirements" },
		{ "name": "autonomous driving", "level": 2, "domain": "requirements" },
		{ "name": "capacity of 6 bottles", "level": 2, "domain": "requirements" },
		{ "name": "beer delivery", "level": 1, "domain": "requirements" },
		{ "name": "to store bottles", "level": 3, "domain": "functional" },
		{ "name": "to absorb impact", "level": 3, "domain": "functional" },
		{ "name": "to provide stable movement from A to B", "level": 3, "domain": "functional" },
		{ "name": "to reduce speed", "level": 3, "domain": "functional" },
		{ "name": "to provide energy", "level": 3, "domain": "functional" },
		{ "name": "to transmit power", "level": 3, "domain": "functional" },
		{ "name": "to store energy", "level": 3, "domain": "functional" },
		{ "name": "to control speed", "level": 3, "domain": "functional" },
		{ "name": "to control direction", "level": 3, "domain": "functional" },
		{ "name": "to control braking", "level": 3, "domain": "functional" },
		{ "name": "to interface between sensors and actors", "level": 3, "domain": "functional" },
		{ "name": "to display information", "level": 3, "domain": "functional" },
		{ "name": "to provide feedback", "level": 3, "domain": "functional" },
		{ "name": "to avoid obstacles", "level": 3, "domain": "functional" },
		{ "name": "to detect paths", "level": 3, "domain": "functional" },
		{ "name": "to detect load", "level": 3, "domain": "functional" },
		{ "name": "housing functions", "level": 2, "domain": "functional" },
		{ "name": "undercarriage functions", "level": 2, "domain": "functional" },
		{ "name": "power supply functions", "level": 2, "domain": "functional" },
		{ "name": "control unit functions", "level": 2, "domain": "functional" },
		{ "name": "HMI functions", "level": 2, "domain": "functional" },
		{ "name": "sensors functions", "level": 2, "domain": "functional" },
		{ "name": "robot functions", "level": 1, "domain": "functional" },
		{ "name": "mechanical switch", "level": 4, "domain": "structural" },
		{ "name": "spring", "level": 4, "domain": "structural" },
		{ "name": "tape line", "level": 4, "domain": "structural" },
		{ "name": "tracking sensor", "level": 4, "domain": "structural" },
		{ "name": "box", "level": 3, "domain": "structural" },
		{ "name": "tray", "level": 3, "domain": "structural" },
		{ "name": "base plate", "level": 3, "domain": "structural" },
		{ "name": "labeling", "level": 3, "domain": "structural" },
		{ "name": "door with hinge", "level": 3, "domain": "structural" },
		{ "name": "lock", "level": 3, "domain": "structural" },
		{ "name": "foam or hemp", "level": 3, "domain": "structural" },
		{ "name": "wheels", "level": 3, "domain": "structural" },
		{ "name": "axle", "level": 3, "domain": "structural" },
		{ "name": "platform", "level": 3, "domain": "structural" },
		{ "name": "shaft", "level": 3, "domain": "structural" },
		{ "name": "coupler", "level": 3, "domain": "structural" },
		{ "name": "e-motor", "level": 3, "domain": "structural" },
		{ "name": "brakes", "level": 3, "domain": "structural" },
		{ "name": "arduino", "level": 3, "domain": "structural" },
		{ "name": "charging control unit", "level": 3, "domain": "structural" },
		{ "name": "solar panel", "level": 3, "domain": "structural" },
		{ "name": "battery pack", "level": 3, "domain": "structural" },
		{ "name": "wires/cables", "level": 3, "domain": "structural" },
		{ "name": "weight sensor", "level": 3, "domain": "structural" },
		{ "name": "ultrasonic sensor", "level": 3, "domain": "structural" },
		{ "name": "line tracker", "level": 3, "domain": "structural" },
		{ "name": "acoustic signal", "level": 3, "domain": "structural" },
		{ "name": "LCD with I2C", "level": 3, "domain": "structural" },
		{ "name": "housing module", "level": 2, "domain": "structural" },
		{ "name": "undercarriage module", "level": 2, "domain": "structural" },
		{ "name": "power supply module", "level": 2, "domain": "structural" },
		{ "name": "control unit module", "level": 2, "domain": "structural" },
		{ "name": "HMI module", "level": 2, "domain": "structural" },
		{ "name": "sensors module", "level": 2, "domain": "structural" },
		{ "name": "robot structure", "level": 1, "domain": "structural" }
	],
	"links": [
		{ "source": "beer delivery", "target": "delivery in 10 minutes" },
		{ "source": "beer delivery", "target": "distance of 6 km" },
		{ "source": "beer delivery", "target": "autonomous driving" },
		{ "source": "beer delivery", "target": "capacity of 6 bottles" },
		{ "source": "autonomous driving", "target": "path detection" },
		{ "source": "autonomous driving", "target": "steering" },
		{ "source": "autonomous driving", "target": "obstacle avoidance" },
		{ "source": "autonomous driving", "target": "enable communication between subsystems" },
		{ "source": "capacity of 6 bottles", "target": "weight detection" },
		{ "source": "capacity of 6 bottles", "target": "thermal insulation" },
		{ "source": "capacity of 6 bottles", "target": "damping" },
		{ "source": "capacity of 6 bottles", "target": "compact sizing" },
		{ "source": "robot structure", "target": "housing module" },
		{ "source": "robot structure", "target": "undercarriage module" },
		{ "source": "robot structure", "target": "power supply module" },
		{ "source": "robot structure", "target": "control unit module" },
		{ "source": "robot structure", "target": "HMI module" },
		{ "source": "robot structure", "target": "sensors module" },
		{ "source": "housing module", "target": "box" },
		{ "source": "housing module", "target": "tray" },
		{ "source": "housing module", "target": "base plate" },
		{ "source": "housing module", "target": "labeling" },
		{ "source": "housing module", "target": "door with hinge" },
		{ "source": "housing module", "target": "lock" },
		{ "source": "housing module", "target": "foam or hemp" },
		{ "source": "undercarriage module", "target": "wheels" },
		{ "source": "undercarriage module", "target": "axle" },
		{ "source": "undercarriage module", "target": "platform" },
		{ "source": "undercarriage module", "target": "shaft" },
		{ "source": "undercarriage module", "target": "coupler" },
		{ "source": "undercarriage module", "target": "e-motor" },
		{ "source": "undercarriage module", "target": "brakes" },
		{ "source": "control unit module", "target": "arduino" },
		{ "source": "control unit module", "target": "charging control unit" },
		{ "source": "power supply module", "target": "solar panel" },
		{ "source": "power supply module", "target": "battery pack" },
		{ "source": "power supply module", "target": "wires/cables" },
		{ "source": "sensors module", "target": "weight sensor" },
		{ "source": "sensors module", "target": "ultrasonic sensor" },
		{ "source": "sensors module", "target": "line tracker" },
		{ "source": "HMI module", "target": "acoustic signal" },
		{ "source": "HMI module", "target": "LCD with I2C" },

		{ "source": "robot functions", "target": "housing functions" },
		{ "source": "robot functions", "target": "undercarriage functions" },
		{ "source": "robot functions", "target": "power supply functions" },
		{ "source": "robot functions", "target": "control unit functions" },
		{ "source": "robot functions", "target": "HMI functions" },
		{ "source": "robot functions", "target": "sensors functions" },
		{ "source": "housing functions", "target": "to store bottles" },
		{ "source": "housing functions", "target": "to absorb impact" },
		{ "source": "undercarriage functions", "target": "to provide stable movement from A to B" },
		{ "source": "undercarriage functions", "target": "to reduce speed" },
		{ "source": "power supply functions", "target": "to provide energy" },
		{ "source": "power supply functions", "target": "to transmit power" },
		{ "source": "power supply functions", "target": "to store energy" },
		{ "source": "control unit functions", "target": "to control speed" },
		{ "source": "control unit functions", "target": "to control direction" },
		{ "source": "control unit functions", "target": "to control braking" },
		{ "source": "control unit functions", "target": "to interface between sensors and actors" },
		{ "source": "HMI functions", "target": "to display information" },
		{ "source": "HMI functions", "target": "to provide feedback" },
		{ "source": "sensors functions", "target": "to avoid obstacles" },
		{ "source": "sensors functions", "target": "to detect paths" },
		{ "source": "sensors functions", "target": "to detect load" },
		{ "source": "weight sensor", "target": "mechanical switch" },
		{ "source": "weight sensor", "target": "spring" },
		{ "source": "line tracker", "target": "tape line" },
		{ "source": "line tracker", "target": "tracking sensor" }
	],
	"traces": [
		{ "nodeids":"54,21" },
		{ "nodeids":"40,13" },
		{ "nodeids":"45,13" },
		{ "nodeids":"14,46" },
		{ "nodeids":"15,47" },
		{ "nodeids":"15,48" },
		{ "nodeids":"15,52" },
		{ "nodeids":"16,53" },
		{ "nodeids":"17,56" },
		{ "nodeids":"18,58" },
		{ "nodeids":"19,57" },
		{ "nodeids":"20,54" },
		{ "nodeids":"22,54" },
		{ "nodeids":"23,54" },
		{ "nodeids":"24,63" },
		{ "nodeids":"25,62" },
		{ "nodeids":"26,60" },
		{ "nodeids":"27,61" },
		{ "nodeids":"27,38" },
		{ "nodeids":"27,39" },
		{ "nodeids":"28,59" },
		{ "nodeids":"0,27" },
    { "nodeids":"1,20" },
    { "nodeids":"1,21" },
    { "nodeids":"1,22" },
    { "nodeids":"1,15" },
    { "nodeids":"1,16" },
    { "nodeids":"2,26" },
    { "nodeids":"3,23" },
    { "nodeids":"4,28" },
    { "nodeids":"6,14" },
    { "nodeids":"9,15" }

	]
}

var clickedElemList = [];
var curTrial = 0;
var nTrials = 5;
var taskType = 5;
var taskTypes = 4;
var startTrialTime;

var viewerWidth = $(document).width();
var viewerHeight = $(document).height();

var nodes = json.nodes;
var treelinks = json.links;
var traces = json.traces;

//TODO: fix tracing - it stops when it reaches Requirements domain
//in task 2 - make sure that answers yes and no are 50/50
//in task 5 - make sure that rootNodes are not in the question, because the users will have to click on all of them

var globaldomains = ["structural","functional","requirements"];

//add IDs to nodes
for (j = 0; j < nodes.length; j++) {
	nodes[j].nodeid = j;
}

console.log("initial nodes:", nodes);

var userTraces = getTracesFromFile(); //return global array of unordered full traces
//trace1: source, p1, p2, p3,..., target
//trace2: source, p1, p2, p3,..., target

//TODO: write function that combines traces
//var srtTraces = sortTracesByDomainAndLevel(userTraces);

//console.log("srtTraces: ", srtTraces);

//var srtlvlTraces = sortTracesByLevels(srtTraces);
//var cmbTraces = combineAllTraces(srtTraces);

//combineTraces(srtTraces);
//getTracingDictFullArrayTwo(userTraces, nodes);

//dictionary, where key = nodeID, value = list of connected nodes from traces
//var tracingDictFull = getTracingDictFullArray(userTraces, nodes);
var tracingDictFull = getTracingDictFullArray(userTraces, nodes);
var tracingDictFullTwo = getTracingDictFullArrayTwo(userTraces, nodes)
console.log("tracingDictFull: ", tracingDictFull);

//TODO: combine traces within tracingDictFullTwo array
//first, sort by domains and levels
//second, find common trace slices, add nodes in those slices to tracingDictFullTwo[j]
var sortedTracingDictFullTwo = sortTracesByDomainAndLevel(tracingDictFullTwo);

var sortedMergedTracingDictFullTwo = mergeTracesWithinTracingDictFullTwo(sortedTracingDictFullTwo);

//array of links from all traces
//var tracelinks = getLinksFromTraces(userTraces);
var tracelinks = getLinksFromTraces(userTraces);
//console.log("all tracelinks:", tracelinks);

//console.log("all treelinks: ", treelinks);
//we distinguish between hierarchical links and links that are generated from the traces
//rewrite this so that it adds only links that are not present in treelinks
var links = treelinks.concat(tracelinks);

links = inverseLinks(links);

//var links = mergeLinks(treelinks, tracelinks);

//console.log("merged links: ", links);
//inverse links, if their source is larger level, that target
//and if within same domain
function inverseLinks(links) {
	var resultlinks = [];
	for (var i = 0; i < links.length; i++) {
		source = getNodeIndexByName(links[i].source);
		target = getNodeIndexByName(links[i].target);
		//console.log("current link:", links[i]);
		if (nodes[source].domain == nodes[target].domain && nodes[source].level > nodes[target].level) {
			links[i].source = nodes[target].name;
			links[i].target = nodes[source].name;
			//console.log("link: " + links[i] + " have changed")
		}
	}
	return links;
}

//combine separate traces to create long traces
function mergeTracesWithinTracingDictFullTwo(tracingDictFull) {
//console.log("mergeTracesWithinTracingDictFullTwo...");
//go through each item in the tracingDictFull
	var resultDict = [];
	for (var i = 0; i < tracingDictFull.length; i++) {
		resultDict[i] = [];
		var nodetrace1 = tracingDictFull[i];
		for (var j = 0; j < tracingDictFull.length; j++) {
			if (i==j)
				continue;
			var nodetrace2 = tracingDictFull[j];
		//for each domain in nodetrace dict,
			for (var k = 0; k < globaldomains.length; k++) {
				var curdomain = globaldomains[k];
				/*console.log("curdomain:", curdomain);
				console.log("nodetrace1[curdomain]:", nodetrace1[curdomain]);
				console.log("nodetrace2[curdomain]:", nodetrace2[curdomain]);*/
				if (nodetrace1[curdomain] == nodetrace2[curdomain]) {
					var merged = mergeTwoTraces(nodetrace1, nodetrace2);
				}
			}
		}
		resultDict[i].push(merged);
	}
	return resultDict;

	/*for (var l = 0; l < globaldomains.length; l++) {
		for (var j = 0; j < sortedTraces.length; j++) {
			var trace1 = sortedTraces[j];
			console.log("trace1[globaldomains[l]]", trace1[globaldomains[l]]);
			for (var k = 0; k < sortedTraces.length; k++) {
				var trace2 = sortedTraces[k];
				console.log("trace2[globaldomains[l]]", trace2[globaldomains[l]]);
				if (trace1[globaldomains[l]] == trace2[globaldomains[l]] && j!=k && trace1[globaldomains[l]] != []) {
					mergeTwoTraces(trace1, trace2);
				}
			}
		}
	}*/
}

function mergeTwoTraces(trace1, trace2) {
	console.log("mergeTwoTraces...");
	//console.log("trace1:", trace1);
	//console.log("trace2:", trace2);
}

function sortTracesByDomainAndLevel(tracingDict) { //second version of sortByDomain
	console.log("sortTracesByDomainAndLevel...");
	var resultedarray = [];
	//this sorts only by domains, but not by levels
	for (var j = 0; j < tracingDict.length; j++) {
		//console.log("traceArray[j]:",traceArray[j]);
		var tracedomnodes = {};
		for (var k = 0; k < globaldomains.length; k++) {
			tracedomnodes[globaldomains[k]] = [];
			for (var l = 0; l < tracingDict[j].length; l++) {
				if (tracingDict[j][l].domain == globaldomains[k]) {
					tracedomnodes[globaldomains[k]].push(tracingDict[j][l]);//array that contains nodes with one trace, belonging to one domain
					//semiresultedarray.push(traceArray[j]);
				}
			}
			tracedomnodes[globaldomains[k]].sort(compareLevels);
		}
		//console.log("tracedomnodes:",tracedomnodes);
		resultedarray.push(tracedomnodes);
	}
	//console.log("resultedsortedarray:",resultedarray);
	return resultedarray;
} //end function

//sorts nodes according to their levels
//https://stackoverflow.com/questions/1129216/sort-array-of-objects-by-string-property-value
//usage: objs.sort( compare );
function compareLevels( a, b ) {
  if ( a.level < b.level ){
    return -1;
  }
  if ( a.level > b.level ){
    return 1;
  }
  return 0;
}

//given full trace array, sorts by domains REQS - FUNCTIONS - STRUCTURE
function sortByDomain(traceArray) {
	//console.log("sortByDomain..");
	//first, fill dict where key is domain name,
	//value is array of nodes in that domain
	var domaintraces = {};
	//var resultarray = [];
	for (var j = 0; j < traceArray.length; j++) {
			if (domaintraces[traceArray[j].domain] != null) {
				domaintraces[traceArray[j].domain].push(traceArray[j]);
			} else {
				domaintraces[traceArray[j].domain] = [];
				domaintraces[traceArray[j].domain].push(traceArray[j]);
			}
	}
	//console.log("domaintraces:", domaintraces);
	//second, go through global array of domain names with correct order,
	//create result array based on this order
	var resultarray = domaintraces[globaldomains[0]];
	if (resultarray == null) {
		resultarray = [];
	}
	for (var j = 1; j < globaldomains.length; j++) {
		//console.log("domaintraces[globaldomains[j]]", domaintraces[globaldomains[j]]);
		//console.log("globaldomains[j]", globaldomains[j]);
		resultarray = resultarray.concat(domaintraces[globaldomains[j]]);
	}
	resultarray.pop(); //HACK: remove last "undefined" element
	/*for (var j = 0; j < resultarray.length; j++) {
		if (resultarray[j] == null)
			resultarray.pop();
	}*/

	console.log("sorted domaintraces:", resultarray);
	return resultarray;
}

//function that returns an array of source-targets from the traces
function getLinksFromTraces(userTraces) {
	//console.log("getLinksFromTraces ... ");
	var tracelinks = [];
	for (var j = 0; j < userTraces.length; j++) {
		var fulltraceArray = userTraces[j];
		//sort by domains, so that edges go starting from right to left
		fulltraceArray = sortByDomain(fulltraceArray);
		//console.log("fulltraceArray:", fulltraceArray);

		//for each node in trace, create link from this node, to next one
		for (var k = 0; k < fulltraceArray.length - 1; k++) {
			var tracelink = {};
			tracelink.source = fulltraceArray[k].name;
			tracelink.target = fulltraceArray[k+1].name;
			tracelinks.push(tracelink);
		}
	}
	return tracelinks;
}

function getTracingDictFullArrayTwo (userTraces, nodes) { //second version
	var resultarray = [];
	for (var j = 0; j < nodes.length; j++) {
		resultarray[j] = [];
		//iterate all traces, find traces that contain this node
		//extract all nodes from these traces, merge them into one array
		//remove duplicates
		for (var k = 0; k < userTraces.length; k++) {
			var trace = userTraces[k];
			var tracenodeids = getNodeIDsFromTrace(trace);
			//console.log("fulltraceArray:", fulltraceArray);
			if (tracenodeids.indexOf(nodes[j].nodeid) != -1) { //if node is in trace, add all tracenodes to the resultarray[j]
				for (var l = 0; l < tracenodeids.length; l++) {
					if (resultarray[j].indexOf(nodes[tracenodeids[l]]) == -1) {
						resultarray[j].push(nodes[tracenodeids[l]]); //we push node that corresponds to the nodeid in the trace
					}
				}
			}
		}
	}
	//console.log("resultarray:", resultarray);
	return resultarray;
}

//takes an array of full traces,
// returns a dict, where key = nodeID, value = list of connected nodes from traces
function getTracingDictFullArray (userTraces, nodes) {
	//console.log("getTracingDictFullArray...");
	//console.log("fulltraceArray:", fulltraceArray);
	var resultarray = [];

	for (var j = 0; j < nodes.length; j++) {
		resultarray[j] = [];
		for (var k = 0; k < userTraces.length; k++) {
			var fulltraceArray = userTraces[k];
			//console.log("fulltraceArray:", fulltraceArray);
			var tracenodeids = getNodeIDsFromTrace(fulltraceArray);
			//console.log("tracenodeids:", tracenodeids);

			//if nodeid is in tracenodeid list, assign or push fullTraceArray
			if (tracenodeids.indexOf(nodes[j].nodeid) != -1) {
				//console.log("nodes[j]:", nodes[j], "is in tracenodeids", tracenodeids);
				//console.log("resultarray[j]", resultarray[j]);
				resultarray[j].push(fulltraceArray);
			}
		}
	}
	//console.log("resultarray:", resultarray);
	return resultarray;
}

//gets a trace, returns an array of nodeids
function getNodeIDsFromTrace(fulltrace) {
	//console.log("getNodeIDsFromTrace...");
	//console.log("fulltrace...", fulltrace);
	var resultarray = [];
	for (var j = 0; j < fulltrace.length; j++) {
		resultarray.push(fulltrace[j].nodeid);
	}
	return resultarray;
}

//gets a trace array, returns an array of nodeids
function getNodeIDsFromTraceArray(traceArray) {
	//console.log("getNodeIDsFromTraceArray...");
	var resultarray = [];
	for (var j = 0; j < traceArray.length; j++) {
		for (var k = 0; k < traceArray[j].length; k++) {
			resultarray.push(traceArray[j][k].nodeid);
		}
	}
	return resultarray;
}

//takes strings of user defined traces from the file,
//transforms them into array of full traces
function getTracesFromFile () {
	var resultarray = [];
	for (var k = 0; k < traces.length; k++) {
			//take each trace and make it full
			tracenodes = traces[k].nodeids.split(",");
			//console.log("tracenodes:", tracenodes);
			var fulltrace = getFullTraceFromShortTrace(tracenodes);
			//console.log("fulltrace:", fulltrace);
			resultarray.push(fulltrace);
	}
	return resultarray;
}

//takes a user defined route in the form of array of two elements,
//translates it to full route with all nodes along the route
function getFullTraceFromShortTrace(traceArray) {
	//console.log("getFullTraceArray...");
	var fullTraceArray = [];
	//we assume that array is sorted
	for (var j = 0; j < traceArray.length; j++) {
		var curnode = traceArray[j];
		//console.log("current node:", curnode);
		var domroot = getDomainRoot(nodes[curnode], []);
		domroot.unshift(nodes[curnode]);
		//console.log("domroot:", domroot);
		//add all connected nodes within one domain to the overall tracing array
		fullTraceArray = fullTraceArray.concat(domroot);
	}
	//console.log("fullTraceArray: ", fullTraceArray);
	return fullTraceArray;
}

//returns an array of all the ancestors of that node within domain
function getDomainRoot(node, resultarray) {
	//console.log("getDomainRoot for node:", node);
	//console.log("nodeid:", node.nodeid);
	var parent = getParent(node.nodeid, nodes, treelinks);
	//console.log("parent:", parent);
	if (parent != null) {
		//console.log("parent domain:", parent.domain,"node domain:", node.domain);
		if (parent.domain == node.domain) {
			resultarray.push(parent);
			//console.log("resultarray after push:", resultarray);
			resultarray = getDomainRoot(parent, resultarray);
		}
	}
	return resultarray;
}

function getDomainArray() {
	domarray = [];
	domnames = [];
	for (j = 0; j < nodes.length; j++) {
		domindex = domnames.indexOf(nodes[j].domain);
		if (domindex != -1) {
			domarray[domindex].nodes.push(nodes[j]);
	} else {
			domnames.push(nodes[j].domain);
			var domobj = {};
			domobj.name = nodes[j].domain;
			domobj.nodes = [];
			domobj.nodes.push(nodes[j]);
			domarray.push(domobj);
			//console.log("domnames:", domnames);
			//console.log("domarray:", domarray);
		}
	} //end for loop
	//console.log("domarray:", domarray);
	return domarray;
}

//sort domain array by levels, where each array element contains set of nodes for that level
function sortDomainArray(domarray) {
	//console.log("inarray", domarray);
	var outarray = domarray;
		for (var j = 0; j < domarray.length; j++) {
			var domnodes = domarray[j].nodes;
			//create array with maxlevel number of dimensions
			var maxlvl = domarray[j].maxlevel;

			var resultarray = createNDimArray([maxlvl,1]);
			//console.log("resultarray:", resultarray);
			for (var k = 0; k < domnodes.length; k++) {
				var nodelevel =  domnodes[k].level;
				if (resultarray[nodelevel - 1] == null) {
					resultarray[nodelevel - 1] = [];//.push(domnodes[k]);
				} else {
					resultarray[nodelevel - 1].push(domnodes[k]);
				}
			}
			//remove first null element
			for (var k = 0; k < resultarray.length; k++)
				resultarray[k].shift();//removes first null element
			//console.log("domain:", domarray[j].name, "resultarray after", resultarray);
			outarray[j].nodes = resultarray;
		}
		//console.log("outarray", outarray);
		return outarray;
}

//stackoverflow.com/questions/12588618/javascript-n-dimensional-array-creation
function createNDimArray(dimensions) {
 var ret = undefined;
 if(dimensions.length==1){
		ret = new Array(dimensions[0]);
		for (var i = 0; i < dimensions[0]; i++)
				ret[i]=null; //or another value
		return ret;
 }
 else{
		//recursion
		var rest = dimensions.slice(1);
		ret = new Array(dimensions[0]);
		for (var i = 0; i < dimensions[0]; i++)
				ret[i]=createNDimArray(rest);
		return ret;
 }
}

function getParent(nodeindex, nodes, treelinks) {
//  console.log("treelinks:", treelinks);
//      console.log("nodeindex:", nodeindex);
	var parent = null;
	for (j = 0; j < treelinks.length; j++) {
		link = treelinks[j];
		source = getNodeIndexByName(link.source);
		target = getNodeIndexByName(link.target);
		if (source == nodeindex) {
			//console.log(link);
			//console.log(nodeindex,nodes[nodeindex].name, nodes[target].name, nodes[target].level);
			if (nodes[target].level < nodes[nodeindex].level && nodes[target].domain == nodes[nodeindex].domain)
				//put into children list
				parent = nodes[target];
				//console.log("node: ", nodes[nodeindex], "target: ", nodes[target]);
		}//if
		if (target == nodeindex) {
			//console.log(link);
			//console.log(nodeindex,nodes[nodeindex].name, nodes[source].name, nodes[source].level);
			if (nodes[source].level < nodes[nodeindex].level && nodes[source].domain == nodes[nodeindex].domain)
				//put into children list
				parent = nodes[source];
				//console.log("node: ", nodes[nodeindex], "source: ", nodes[source]);
		}//if
	}//for loop

	//TODO: Make sure that parent belongs to the same domain as a child
	return parent
}

function getNodeIndexByName(nodename) {
	//console.log("getNodeIndexByName function...");
	//console.log("nodes:", nodes);
	//console.log("nodename:", nodename);
	for (var j = 0; j < nodes.length; j++) {
		//console.log("domainelement.nodes[j].id:", domainelement.nodes[j].nodeid, "nodeid:", nodeid);
		if (nodename == nodes[j].name) {
			//iterate within that domain and count how many nodes are there at that level
				//console.log("return nodeindex:", j);
				return j;
		}
	}
//      return null;
}

function getChildren(nodeindex, nodes, treelinks) {
//Given a node index, returns a list of children for this node
		//go through each link
			//if link.source == nodeindex
				//check level of nodes[link.target]
				//- if level is lower than current node (nodes[nodeindex]), then add to the children list
			//if link.target == nodeindex
				//check level of nodes[link.source] - if level is lower than current node (nodes[nodeindex]), then add to the children list
		children = [];
		//console.log("current node", nodes[nodeindex].name);
		//console.log("getChildren:");
		for (var j = 0; j < treelinks.length; j++) {
			link = treelinks[j];
			//console.log(link);
			source = getNodeIndexByName(link.source);
			target = getNodeIndexByName(link.target);
			if (nodes[target].domain == nodes[nodeindex].domain && nodes[source].domain == nodes[nodeindex].domain) {
				if (source == nodeindex) {
					//console.log(nodeindex,nodes[nodeindex].name, nodes[target].name, nodes[target].level);
					if (nodes[target].level > nodes[nodeindex].level)
						//put into children list
						children.push(nodes[target]);
				}//if
				if (target == nodeindex) {
					if (nodes[source].level > nodes[nodeindex].level)
						//put into children list
						children.push(nodes[source]);
				}//if
			}
		}//for loop
		//console.log("number of children", children.length);
		return children
}//function

//TODO: check tracking from Requirements to Structure - does not track till the end

function generateQuestions(nodes, links) {
	var counter = 0;
	var questions = [];
	var viztypes = ['matrix','tree'];
	for (var t = 0; t < 2; t++) { //run twice
		for (var j = 0; j < viztypes.length; j++) {
			for (var i = 0; i < taskTypes; i++) {
				var question = {};
				//question.text = "Find node " + nodes[randomNode(0, nodes.length-1)].name;
				switch(i) {
				  case 0:
						var qstnode = nodes[randomNode(0, nodes.length-1)]
				    question.text = "Find entity \"" + qstnode.name.toString().toUpperCase() + "\" in the \"" + qstnode.domain.toString().toUpperCase() + "\" domain. \r For matrix, click on the entity name to the left of the matrix. For tree, click on the node itself. After the desired answer is marked with RED color, press \"Submit current answer\" button";
						question.nodes = qstnode;
				    break;
				  case 1:
						var pathpair = getPairWithPath();
				    question.text = "Is there a link between entity \"" + pathpair[0].name.toString().toUpperCase() + "\" in the \"" + pathpair[0].domain.toString().toUpperCase() + "\" domain and entity \"" + pathpair[1].name.toString().toUpperCase() + "\" in the \"" + pathpair[1].domain.toString().toUpperCase() + "\" domain? Choose either Yes or No in field above and press \"Submit current answer\" button";
						question.nodes = pathpair;
						//TODO: enable highlighting only for this task type
				    break;
				  case 2:
						var qstnode = nodes[randomNode(0, nodes.length-1)]
				    question.text = "How many connections does entity \"" + qstnode.name.toString().toUpperCase() + "\" in the \"" + qstnode.domain.toString().toUpperCase() + "\" domain have? Enter the number in the field above and press \"Submit current answer\" button";
				    break;
					/*case 3:
						var pathpair = getPairWithPath();
					  question.text = "Please mark ALL entities on a path from entity \"" + pathpair[0].name.toString().toUpperCase() + "\" in the \"" + pathpair[0].domain.toString().toUpperCase() + "\" domain to entity \"" + pathpair[1].name.toString().toUpperCase() + "\" in the \"" + pathpair[1].domain.toString().toUpperCase() + "\" domain. After you have marked all the desired entities with RED color, " + "press \"Submit current answer\" button";
						question.nodes = pathpair;
					  break;*/
					case 3:
						var qstnode = nodes[randomNode(0, nodes.length-1)]
					  question.text = "Please mark ALL entities connected to entity \"" + qstnode.name.toString().toUpperCase() + "\" in the \"" + qstnode.domain.toString().toUpperCase() + "\" domain. After you have marked all the desired entities with RED color, " + "press \"Submit current answer\" button";
					  break;
				}
				question.type = i;
				question.viz = viztypes[j];
				questions[counter] = question;
				counter++;
			}
		}
	}
	console.log("questions:", questions);
	return questions;
}

console.log("start generating questions...");

var generatedQs = generateQuestions(nodes, links); //array of generated questions

//randomize the order of questions
shuffleArray(generatedQs);


//return a pair of nodes, between which a path exists
function getPairWithPath() {
	var pathExists = false;
	var resultpair = [];
	while (pathExists == false) {
	//for (var i = 0; i < 150; i++) {
		var nodea = nodes[randomNode(0, nodes.length-1)];
		var nodeb = nodes[randomNode(0, nodes.length-1)];
		//FORK HERE
		//pathExists = checkPathExists(nodea, nodeb);
		pathExists = checkPathExistsTwo(nodea, nodeb);
		//console.log("Path between A:" + nodea.name + " B:" + nodeb.name + "exists:" + pathExists);
		if (pathExists == true) {
			resultpair.push(nodea);
			resultpair.push(nodeb);
			return resultpair;
		}
	}
}

//checks in node A and node B are connected (could be indirectly)
function checkPathExists (nodea,nodeb){
		if (nodea == nodeb)
			return false;
			//check tracingDictFull for node A contains node B
		var nodetraces = tracingDictFull[nodea.nodeid];
		//console.log("tracingDictFull:", tracingDictFull);
		//console.log("nodea:", nodea);
		//go through each trace
		if (nodetraces != null) {
			//console.log("nodetraces:",nodetraces);
			for (var i = 0; i < nodetraces.length; i++) {
				var trace = nodetraces[i]; //array of nodes
				//console.log("trace:", trace);
				//shuffle trace, because otherwise will always return higher level nodes
				shuffleArray(trace);
				//console.log("shuffled trace:", trace);
				for (var j = 0; j < trace.length; j++) {
					//console.log("is " + trace[j].nodeid + "equal to?" + nodeb.nodeid);
					if (trace[j].nodeid == nodeb.nodeid)
						return true;
				}
			}
		}
		return false;
}

function checkPathExistsTwo (nodea,nodeb){
		if (nodea == nodeb)
			return false;
			//check tracingDictFull for node A contains node B
		var nodetrace = tracingDictFullTwo[nodea.nodeid];
		//console.log("tracingDictFull:", tracingDictFull);
		//console.log("nodea:", nodea);
		//go through each trace
		if (nodetrace != null) {
			//console.log("nodetraces:",nodetraces);
			//shuffle trace, because otherwise will always return higher level nodes
			shuffleArray(nodetrace);
				//console.log("shuffled trace:", trace);
				for (var j = 0; j < nodetrace.length; j++) {
					//console.log("is " + trace[j].nodeid + "equal to?" + nodeb.nodeid);
					if (nodetrace[j].nodeid == nodeb.nodeid)
						return true;
				}
			}
		return false;
}

//https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array
function shuffleArray(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}

//from here: https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range/14790863
function randomNode(bottom, top) {
	return Math.floor(Math.random() * (+bottom - +top)) + +top;
}

function getRedNodesData(answerVizType) {
	//console.log("getRedNodesData..", curTrial);
	//var container = d3.select("#treecontainer" + curTrial);
	//console.log("treecontainer:", container);
	var svgGroup = d3.select('#svgGroup' + curTrial);
	var selectionstring = '';

	if (answerVizType == 'matrix') {
		selectionstring = ".row text"
	} else if (answerVizType == 'tree'){
		selectionstring = ".nodes"
	}

	var rednodes = svgGroup.selectAll(selectionstring)
					.filter(function(d,i){
						var nodecolor = d3.select(this).attr('fill');
						return nodecolor == 'red';
					});

	var matrixtexts = svgGroup.selectAll(".row text")
					.filter(function(d,i){
						var nodecolor = d3.select(this).attr('fill');
						return nodecolor == 'red';
					});

	//console.log("rednodes:", rednodes.data());
	//console.log("matrixtexts:", matrixtexts);


	var resultarray = [];
	if (answerVizType == 'tree') {
		var reddata = rednodes.data();
		for (i = 0; i < reddata.length; i++) {
			console.log("current answers:", reddata[i].nodeid);
			resultarray.push(reddata[i].nodeid);
		}
		//return rednodes.data(); }
		return resultarray; }
	else if (answerVizType == 'matrix') {
		//return getDataFromNodes(rednodes); }
		for (i = 0; i < matrixtexts[0].length; i++) {
			//console.log("current answers:", rednodes[i]);
			resultarray.push(matrixtexts[0][i].id);
		}
		//return resultarray; }
		return resultarray; }

}

var answers = []; //array of answers for each question
var responsetimes = [];

function download(data, filename, type) {
    var file = new Blob([data], {type: type});
    if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
        var a = document.createElement("a"),
                url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    }
}

function buttonClicked() { //click on "responseButton"

	//remember answer, store it somewhere
	var answerTaskType = generatedQs[curTrial].type;
	var answerVizType = generatedQs[curTrial].viz;
	//console.log("curTrial:", curTrial);
	switch(answerTaskType) {
		case 0:
		//	question.text = "Find node " + qstnode.name;
		//find and store all selected/red nodes
		var rednodesdata = getRedNodesData(answerVizType);
		answers.push(rednodesdata);
		break;
		//console.log("answers so far:", answers);
		case 1:
		//	question.text = "Is there a link between node " + pathpair[0].name + " and node " + pathpair[1].name + "?";
		//store Yes/No radiobutton
		//$('#radiowrapper').show();
		//$('#numberwrapper').hide();
		//console.log(document.getElementById("radiowrapper").getElementsByTagName('p')[0].getElementsByTagName('input')[0].checked);
		//console.log(document.getElementById("radiowrapper").getElementsByTagName('p')[1].getElementsByTagName('input')[0].checked);
		if (document.getElementById("radiowrapper").getElementsByTagName('p')[0].getElementsByTagName('input')[0].checked) {
			answers.push('yes');
		} else if (document.getElementById("radiowrapper").getElementsByTagName('p')[1].getElementsByTagName('input')[0].checked) {
			answers.push('no');
		}
		break;
		//console.log(document.getElementById("radiowrapper").getElementsByTagName('p')[1]);
		case 2:
		//	question.text = "How many incoming/outgoing edges does node " + qstnode.name + " have?";
		//store number input
		//$('#radiowrapper').hide();
		console.log(document.getElementById("numberwrapper").getElementsByTagName('input')[0].value);
		answers.push(document.getElementById("numberwrapper").getElementsByTagName('input')[0].value);
		document.getElementById("numberwrapper").getElementsByTagName('input')[0].value = 0;
		break;
		/*case 3:
		//	question.text = "Please mark all nodes on a path from node " + pathpair[0].name + " to node " + pathpair[1].name;
		//find and store ids of all red nodes
		answers.push(getRedNodesData(answerVizType));*/
		break;
		case 3:
		//	question.text = "Please mark all nodes connected to node " + qstnode.name;
		//find and store ids of all red nodes
		answers.push(getRedNodesData(answerVizType));
		break;
	}

	console.log("answers:", answers);

	var curTime = new Date();
	//console.log("curTrial:",curTrial);
	var rt = curTime - startTrialTime;
	console.log(rt);
	responsetimes.push(rt);
	$('#trial' + curTrial).hide();
	//$('#radiowrapper').hide();
	//$('#numberwrapper').hide();

	curTrial++;
	document.getElementById('trialcounter').innerHTML = "Question #" + (curTrial + 1) + " out of " + generatedQs.length;
	if (curTrial > generatedQs.length-1) {
		$('#submitButton').show();
		alert('Thank you for participation!');
		console.log("FINAL ANSWERS:", answers);
		answers.toString();
		generatedQs.toString();
		responsetimes.toString();
		var outputstr = "question type | question | answer | responsetime \n";
		for (var i = 0; i < generatedQs.length; i++) {
			outputstr = outputstr + generatedQs[i].type + " | " + generatedQs[i].text + " | " + answers[i] + " | " + responsetimes[i] + " \n";
		//"ANSWERS:\n" + answers + "\n" +  "QUESTIONS:\n" + generatedQs.text + "\n" + responsetimes;
		}
		console.log("outputstr:", outputstr);
		download(outputstr, 'total.txt', 'text/plain');

	} else {
		//show it
		$('#trial' + curTrial).show();

		document.getElementById('trial' + curTrial).getElementsByTagName('p')[0].innerHTML
		//FIELDS DISPLAY LOGIC
		displayFields(generatedQs[curTrial].type);

		//FOR REFERENCE
		//change label on trial# element
		//console.log("innerHTML p:" + document.getElementById('trial' + curTrial).getElementsByTagName('p')[0].textContent);

		document.getElementById('trial' + curTrial).getElementsByTagName('p')[0].innerHTML = generatedQs[curTrial].text;
		//$("#trial2 > p").text('test');

		if (generatedQs[curTrial].viz == 'matrix') {
			showMatrix(curTrial, generatedQs[curTrial].type);
		} else if (generatedQs[curTrial].viz == 'tree') {
			showTree(curTrial, generatedQs[curTrial].type);
		}
			//then drawMatrix
			//else if question.viz == 'tree'
			//then showTree
		//showTree(curTrial, generatedQs[curTrial].type);
		startTrialTime = new Date();
	}
}

//TODO: move radio and number above tree
function displayFields(questiontype) {
	//console.log("displayFields... with type:", questiontype);
	switch (questiontype) {
		case 1:
		$('#numberwrapper').hide();
		$('#radiowrapper').show();
		break;
		case 2:
		$('#radiowrapper').hide();
		$('#numberwrapper').show();
		document.getElementById("numberwrapper").getElementsByTagName('input')[0].value = 0;
		//console.log("case 2 executed..");
		break;
		default:
		$('#numberwrapper').hide();
		$('#radiowrapper').hide();
		break;
	}

}

function getFirstLevelNodes() {
	var resultarray = [];
	for (var j = 0; j < nodes.length; j++) {
		if (nodes[j].level == 1)
			resultarray.push(nodes[j]);
	}
	return resultarray;
}

function getNewLinks() {
	var resultarray = [];
	for (var j = 0; j < nodes.length; j++) {
		var curnode = nodes[j];
		var tracearrays = tracingDictFull[nodes[j].nodeid];
		//console.log("newlinks nodes[j].nodeid:", nodes[j].nodeid);
		//console.log("tracearrays:", tracearrays);
		for (var k = 0; k < tracearrays.length; k++) {
			var curtracearray = tracearrays[k];
			for (var l = 0; l < curtracearray.length; l++) {
				var newlink = {};
				newlink.source = nodes[j].name;
				newlink.target = curtracearray[l].name;
				resultarray.push(newlink);
			}
		}
	}
	return resultarray;
}


//adapted from https://bl.ocks.org/emeeks/15c005cba60aad26e11a
function showMatrix(curTrial, taskType) {
	//alert('showMatrix with taskType:' + taskType);
	//console.log('original links:', links);

	d3.select("#tree-container" + curTrial)
		.style("margin-top", -80 + "px")

	//var matrixnodes = sortNodesByLevels(nodes);
//	var matrixnodes = sortNodesByTree(nodes);


var firstlevels = getFirstLevelNodes();
//for each rootnode in tree
var treelist = []; //array R1-1.1-1.2-2-2.1-2.2 - F1-1.1

for (var j = 0; j < firstlevels.length; j++) {
	//console.log("firstlevels[j]:", firstlevels[j]);
	var rootNode = firstlevels[j];
	treelist.push(rootNode);

	getTreelist(rootNode);

	function getTreelist(node) {
		var children = getChildren(node.nodeid, nodes, treelinks);
		children.forEach(function(child) {
			//console.log("child:", child);
			treelist.push(child);
			getTreelist(child);
		});
	}
}

//console.log("treelist:", treelist);

	var newlinks = getNewLinks();

	//console.log("newlinks:", newlinks);

	//convert links into index format
	var matrixlinks = getMatrixLinks(newlinks);
	//console.log("matrixlinks:", matrixlinks);

	//var matrixData = adjacencyMatrix();
	var matrix = [];

  //console.log(getDomainArray());
	//console.log(matrixData);

	var someColors = d3.scale.category20b();

	//var x = d3.scaleBand().range([0, width]).paddingOuter(0.25),
			//c = d3.scaleOrdinal(d3.schemeCategory20c).domain([25,0]); //TODO bind color range limit to actual data

	var margin = {top: 120, right: 40, bottom: 40, left: 300};
	var textmargin = 500; //TODO: calculate by the longest word
	var matrixwidth = 800;
	var matrixheight = 800;

	var x = d3.scale.ordinal()
									.domain(d3.range(nodes.length))
									.rangeRoundBands([0, matrixwidth], 0.05);

	var baseSvg = d3.select("#tree-container" + curTrial).append("svg")
									.attr("width", matrixwidth + margin.left + margin.right)
									.attr("height", matrixheight + margin.top + margin.bottom)
									.attr("class", "matrix")
									//.attr("transform", "translate(" + textmargin + "," + textmargin + ")")
									.style("margin-left", margin.left + "px")
									.style("margin-top", margin.top + "px")
									 .append("g")
									.attr("id", "svgGroup" + curTrial)
									.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

									//var svgGroup = baseSvg.append("g")

	//.attr("width", viewerWidth)
	//.attr("height", viewerHeight);
	//.attr("class", "overlay");

	var n = treelist.length;
	//create an empty matrix
	treelist.forEach(function(node, i) {
		//node.index = i;
		//node.count = 0;
		matrix[i] = d3.range(treelist.length).map(function(j) { return {x: j, y: i, z: 0}; });
	});

	//fill in the empty matrix based on links
	//CONTINUE HERE: probably there is a mismatch between indexes of treelist and matrixlinks-link.source and target
	matrixlinks.forEach(function(link) {
		/*console.log("link.source - " + link.source);
		console.log("link.source - " + nodes[link.source].name);
		console.log("link.target - " + link.target);
		console.log("link.target - " + nodes[link.target].name);
		console.log(link.value);*/
		matrix[link.source][link.target].z += link.value;
		matrix[link.target][link.source].z += link.value;
		matrix[link.source][link.source].z += link.value;
		matrix[link.target][link.target].z += link.value;
		//console.log(matrix[link.source][link.target]);
		//treelist[link.source].count += link.value;
		//treelist[link.target].count += link.value;
	});

	//console.log("matrix:", matrix);

	baseSvg.append("rect")
			.attr("class", "background")
			.attr("width", matrixwidth)
			.attr("height", matrixheight);

			var row = baseSvg.selectAll(".row")
					.data(matrix)
				.enter().append("g")
					.attr("class", "row")
					.attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
					//.attr("transform", function(d, i) { return "translate(0," + i*mybandwidth + ")"; })
					.each(row);

			row.append("line")
	  			.attr("x2", matrixwidth);

	  	row.append("text")
	  			//.attr("x", -6)
	  			.attr("x", function(d, i) { return nodes[i].level*(-10) ; })
	  			.attr("y", x.rangeBand() / 2)
	  			.attr("dy", ".32em")
	  			.attr("text-anchor", "end")
	  			.style("font-size", "13px")
	  			.text(function(d, i) {
						var returnstring=nodes[i].name;
						if (nodes[i].level == 1)
							returnstring = returnstring.toUpperCase();
						return returnstring; })
					.attr("id", function(d, i) { return nodes[i].nodeid; })
					.on('click', handleTextMouseClick)
					.on("mouseover", textmouseover)
					.on("mouseout", textmouseout);

			var column = baseSvg.selectAll(".column")
					.data(matrix)
				.enter().append("g")
					.attr("class", "column")
					.attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });
			//		.attr("transform", function(d, i) { return "translate(" + i*mybandwidth + ")rotate(-90)"; });

			column.append("line")
	  			.attr("x1", -matrixwidth);

	  	column.append("text")
	  			.attr("x", 6)
	  			.attr("y", x.rangeBand() / 2)
	  			.attr("dy", ".32em")
	  			.attr("text-anchor", "start")
	  			.style("font-size", "13px")
					.text(function(d, i) {
						var returnstring=nodes[i].name;
						if (nodes[i].level == 1)
							returnstring = returnstring.toUpperCase();
						return returnstring; })
					.attr("id", function(d, i) { return nodes[i].nodeid; })
					.on("mouseover", textmouseover)
					.on("mouseout", textmouseout);
				/*	row.exit().remove()
					column.exit().remove()*/

			function row(row) {
				var cell = d3.select(this).selectAll(".cell")
						.data(row.filter(function(d) { return d.z; }))
					.enter().append("rect")
						.attr("class", "cell")
						.attr("x", function(d) {
							return x(findSortedIndex(d.x)); })
							//return mybandwidth*d.x; })
						.attr("width", x.rangeBand())
						.attr("height", x.rangeBand())
						//.style("fill-opacity", function(d) { return z(d.z); })
						//.style("fill", function(d) { return nodes[d.x].group == nodes[d.y].group ? c(nodes[d.x].group) : null; })
						.style("fill", "blue");
						//.on("mouseover", mouseover)
						//.on("mouseout", mouseout);
				}
				//sort by domains
							baseSvg.selectAll(".row")
							.attr("transform", function(d, i) {
								//find index of i in treelist
								//replace 20 with index*20
								//var sortedindex = sortedIndexArray[i];
								var sortedindex = findSortedIndex(i);
								/*console.log("sortedindex:", sortedindex);
								console.log("i:", i);*/
								return "translate(0," + x(sortedindex) + ")"; });

								//DOES NOT WORK
								baseSvg.selectAll(".column")
								.attr("transform", function(d, i) {
									//find index of i in treelist
									//replace 20 with index*20
									var sortedindex = findSortedIndex(i);
									//console.log("sortedindex:", sortedindex);
									var translatestring = "translate(" + x(sortedindex) +")rotate(-90)";
									console.log("translatestring:", translatestring);
									return translatestring; });
								//return "translate(" + sortedindex*x.rangeBand() +",0)"; });

								baseSvg.append("text")
								.attr("x", 0)
								.attr("y", 0)
								.style("font-size", "16px")
								.style("text-decoration", "underline")
								.text("REQUIREMENTS")
								.attr("transform","translate(-270,150)rotate(-90)");

								baseSvg.append("text")
								.attr("x", 0)
								.attr("y", 0)
								.style("font-size", "16px")
								.style("text-decoration", "underline")
								.text("FUNCTIONS")
								.attr("transform","translate(-270,300)rotate(-90)");

								baseSvg.append("text")
								.attr("x", 0)
								.attr("y", 0)
								.style("font-size", "16px")
								.style("text-decoration", "underline")
								.text("STRUCTURE")
								.attr("transform","translate(-270,600)rotate(-90)");


			function findSortedIndex(i) {
				for (var k = 0; k < treelist.length; k++) {
					if (treelist[k].nodeid == i)
						return k;
				}
			}


			function mouseover(p) {
				d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
				d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
			}

			function mouseout() {
				d3.selectAll("text").classed("active", false);
			}

			function handleTextMouseClick(p, selectedindex) {
				console.log("handleTextMouseClick");
				//console.log("selectedindex:", selectedindex);
				//console.log("p:", p);

				var clickedElem = baseSvg.selectAll(".row text")
					.filter(function(d,i){
						if (i == selectedindex)
							return d;
					})

					console.log("clickedElem.data()[0]:", clickedElem.data()[0]);

				var clickedElemCol = baseSvg.selectAll(".column text")
					.filter(function(d,i){
						if (i == selectedindex)
							return d;
					})

				//console.log("clickedElem fill", clickedElem.attr("fill"));

				if (clickedElem.attr("fill") == "red") { //if already clicked
					//repaint back
					clickedElem.attr({fill: "orange"});
					clickedElemCol.attr({fill: "orange"});//paint columns as well
					//remove from the list of selected nodes
					var index = clickedElemList.indexOf(clickedElem);
					if (index > -1) {
						clickedElemList.splice(index, 1);
					}
				} else {
					//paint as highlighted
					clickedElem.attr({fill: "red"});
					clickedElemCol.attr({fill: "red"});
					//add to the list of selected nodes
					clickedElemList.push(clickedElem);
				}

				if (taskType >= 4) { //for last task types we want to keep not one, but many answer nodes
					//return the whole list
					console.log("clicked list:", clickedElemList);
				} else {
					//return the last element, if any
					if (clickedElemList.length > 0) {
						//console.log("clicked list last elem:", clickedElemList[clickedElemList.length - 1].data()[0]);
					} else {
						//console.log("no items in clicked list");
					}
				}

			}

			function textmouseover(p, selectedindex) {
				//console.log("selectedindex:", selectedindex);
				console.log("original node:", nodes[selectedindex]);
				var orignodeID = nodes[selectedindex].nodeid;
				//console.log("p:", p);
				curtrace = getNodeIDsFromTraceArray(tracingDictFull[orignodeID], nodes);
				console.log("cutrace:", curtrace);
				//curtracetwo = getNodeIDsFromTrace(tracingDictFullTwo[i]);
				baseSvg.selectAll(".row text")
								.filter(function(d,i){
									//if (curtrace.indexOf(i) != -1)
									if (curtrace.indexOf(nodes[i].nodeid) != -1)
										return d;
									})
								.attr("fill", function(d) {
										if (d3.select(this).attr('fill') == "red") {
											return "red";
										} else {
											return "orange";
										}
									});

				baseSvg.selectAll(".column text")
							.filter(function(d,i){
								if (curtrace.indexOf(nodes[i].nodeid) != -1)
									return d;
								})
							.attr("fill", function(d) {
									if (d3.select(this).attr('fill') == "red") {
										return "red";
									} else {
										return "orange";
									}
								});

				//d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
				//d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
			}

			function textmouseout() {
				//console.log("textmouseout");
				//d3.selectAll("text").classed("active", false);
				baseSvg.selectAll(".row text")
				.attr("fill", function(d) {
						if (d3.select(this).attr('fill') == "red") {
							return "red";
						} else {
							return "black";
						}
					});

				baseSvg.selectAll(".column text")
				.attr("fill", function(d) {
						if (d3.select(this).attr('fill') == "red") {
							return "red";
						} else {
							return "black";
						}
					});
			}

}

function handleMouseOverMatrix(d, i) {  // Add interactivity

			//get nodeid = i, index in the nodes list from json
			//console.log(d, "index:", i, "tracingDictFull:", tracingDictFull[i]);

			//find all nodes that share traces with the current node
			//WE USE OTHER VARIANT HERE FOR TRACINGDICTTWO
			curtrace = getNodeIDsFromTraceArray(tracingDictFull[i], nodes);
			curtracetwo = getNodeIDsFromTrace(tracingDictFullTwo[i]);
			/*console.log("curtrace:", curtrace);
			console.log("curtracetwo:", curtracetwo);
			console.log("tracingDictFull[i]:", tracingDictFull[i]);
			console.log("tracingDictFullTwo[i]:", tracingDictFullTwo[i]);
			console.log("sortedTracingDictFullTwo[i]:", sortedTracingDictFullTwo[i]);*/
			//var fulltrace = getFullTracingDict([13,47]);

			//find nodes from trace, highlight them
			svgGroup.selectAll(".am-axis")
							.filter(function(d,i){
								//return d3.select(this).attr('id') > 4;
								console.log("selected node:", d);
								currentID = d3.select(this).attr('id');
								//console.log("currentID:", currentID);
								return curtrace.indexOf(parseInt(currentID)) != -1; //add to selection only if the id of the current node is in the tracelist for the clicked node
								})
							.attr("fill", function(d) {
									if (d3.select(this).attr('fill') == "red") {
										return "red";
									} else {
										return "orange";
									}
								});
				//r: radius * 2

			//IMPLEMENT DOMAINS, ENABLE TRACEBILITY BETWEEN DOMAINS

		}

function sortNodesByLevels(inputnodes) {
	var resultnodes = [];
	for (var i = globaldomains.length-1; i >= 0; i--) {
		for (var j = 1; j < 5; j++) {
			for (var k = 0; k < inputnodes.length; k++) {
				if (inputnodes[k].level == j && inputnodes[k].domain == globaldomains[i]) {
					resultnodes.push(inputnodes[k]);
					//console.log("current inputnode:", inputnodes[j]);
					//console.log("k:", k);
				}
			}
		}
	}
	return resultnodes;
}

function sortNodesByTree(inputnodes) {

}


function getMatrixLinks(inputlinks) {
	//for each inputlink, return new link, where source: inputlinks.source.id,target: inputlinks.target.id
		var outlinks = [];
		for (var j = 0; j < inputlinks.length; j++) {
			var outlink = {};
			outlink.source = getNodeIndexByName(inputlinks[j].source);
			outlink.target = getNodeIndexByName(inputlinks[j].target);
			outlink.value = 1;
			outlinks.push(outlink);
		}
		//console.log('outlinks:', outlinks);
		return outlinks;
}

function showFirstTrial(){
	$('#trial0').show();
	$('#trialcounter').show();
	$('#responseButton').show();

	displayFields(generatedQs[0].type);

	//for each question generate div with id=#trial+curTrial
	for (var j = 1; j < generatedQs.length; j++) {
		generateTrialDiv(j);
	}
	document.getElementById('trial0').getElementsByTagName('p')[0].innerHTML = generatedQs[0].text;


	//showTree(0, generatedQs[0].type);
	if (generatedQs[0].viz == 'matrix') {
		showMatrix(0, generatedQs[0].type);
	} else if (generatedQs[0].viz == 'tree') {
		showTree(0, generatedQs[0].type);
	}

	startTrialTime = new Date();
	$('#startExperiment').hide();
	$('#instructions').hide();
}

$('#startExperiment').click(showFirstTrial);
$('#responseButton').click(buttonClicked);

//generates div for trial in the following format
/*
<div id="trial1" class="trialDiv">
	<p>Trial 1 text. </p>
	<div id="tree-container1"></div>
</div>
*/
//https://stackoverflow.com/questions/14004117/create-div-and-append-div-dynamically
function generateTrialDiv (trialid) {
	var iDiv = document.createElement('div');
	iDiv.id = 'trial' + trialid;
	iDiv.className = 'trialDiv';
	var p = document.createElement('p');
	p.textContent = 'Trial text';
	//p.setAttribute("style=/"margin-bottom:-80px"/");
	var treeDiv = document.createElement('div');
	treeDiv.id = 'tree-container' + trialid;
	iDiv.appendChild(p);
	iDiv.appendChild(treeDiv);
	document.getElementsByTagName('body')[0].appendChild(iDiv);
}

function showTree (curTrial, taskType) {

	//console.log(error);
	// size of the diagram

	// define the zoomListener which calls the zoom function on the "zoom" event constrained within the scaleExtents
	var zoomListener = d3.behavior.zoom()
																.scaleExtent([0.2, 3])
																.on("zoom", zoom);

	/*//get current trial number
	var curTrialCounter = document.getElementById('tempStorage').innerHTML;

	console.log("curTrials:", curTrialCounter);*/
	// define the baseSvg, attaching a class for styling and the zoomListener
	var baseSvg = d3.select("#tree-container" + curTrial).append("svg")
			.attr("width", viewerWidth)
			.attr("height", viewerHeight - 50)
			.attr("class", "overlay")
			//.attr("transform", "translate(" + 150 + "," + 150 + ")")
			.call(zoomListener);

	// Append a group which holds all nodes and which the zoom Listener can act upon.
	var svgGroup = baseSvg.append("g")
												.attr("id", "svgGroup" + curTrial);

	function zoom() {
			//svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
			svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
	}

	svgGroup.attr("transform","translate(100,50)scale(.7,.7)");


	/*baseSvg.call(zoom.on("zoom",zoomListener))
           //.append("svg:g")
           .attr("transform","translate(100,50)scale(.5,.5)");*/

	var radius = 10;

	var distY = 30;
	var distX = 200; //separation between levels within one domain

	//calculates starting positions X for each domain, adds maxlevel parameter for each domain
	function calcDomainPositionsX(domarray) {
		//for each domain, find maxlevel depths
		//find sum of levels for all domains
		//find separation between levels = totalwidth/sum of levels
		sum = 0;
		//console.log("domain:", domarray);
		//for(var domain in domaindict) {
		for (var j = 0; j < domarray.length; j++) {

			var maxlevel = getMaxLevels(domarray[j]);
			//console.log("domain:", domain, "maxlevel:", maxlevel);
			domarray[j].maxlevel = maxlevel;
			//console.log("domain:", domarray[j].name, "maxlevel:", domarray[j].maxlevel);
			// do something with "key" and "value" variables
			sum = sum + maxlevel;
		}

		sepX = viewerWidth / sum;
		//console.log("viewerWidth:", viewerWidth, "sepX:", sepX, "total levels:", sum);

		//assign startX to each domain
		domarray[0].startX = 0;
		for (var j = 1; j < domarray.length; j++) {
			domarray[j].startX = domarray[j-1].startX + sepX * domarray[j-1].maxlevel;
			//console.log("j:", j, "domarray[j-1].startX:", domarray[j-1].startX);
		}

		}//end function

	//main function that determines Y positions of nodes
	//based on https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/
	function calcNodePositionsY(domarray) {
		//nodeposY for first level = viewerHeight / nodeslength for that level and that domain
		//nodeposY for next levels = parent.spaceY / nodeslength for that level
		//where parent.spaceY - height available for that parent
		//console.log("Calculating Y positions for nodes...");

		//for (var j = 0; j < domarray.length; j++) {
		var maxRootNodeY = 0;
		var rootNodes = [];

		for (var j = 0; j < domarray.length; j++) { //CHANGE FOR 0 WHEN DONE WITH TESTING ONE DOMAIN
			var rootNode = domarray[j].nodes[0][0];

			//console.log("initial root:", rootNode);
			var prevdommaxlevel = 0; //max level of the previous domain
			if (j > 0)
				prevdommaxlevel = domarray[j-1].maxlevel

			initializeNodes(rootNode,0,j, prevdommaxlevel);

			//console.log("initialized root:", rootNode);

			// assign initial X and Mod values for nodes
			calcInitNodeY(rootNode); //firstwalk

			//console.log("Calculating Initial Positions Completed -----------------------");
			//console.log(rootNode);
			// ensure no node is being drawn off screen
			checkAllChildrenOnScreen(rootNode);

			// assign final X values to nodes
			calculateFinalPositions(rootNode, 0);

			//find max positionY for root nodes for later vertical alignment of trees
			if (rootNode.positionY > maxRootNodeY)
				maxRootNodeY = rootNode.positionY;

			rootNodes.push(rootNode);
		}

			for (var j = 0; j < rootNodes.length; j++) {
				//TODO: write function that vertically centers trees for each domain
				//console.log("root node:", rootNodes[j]);
				var domstartY = rootNodes[j].positionY;
				vertAlignRootNode(rootNodes[j], domstartY, maxRootNodeY);

			}
		//console.log("domarray after spaceY:", domarray);
	}// end function

	//vertically centers trees for each domain
	function vertAlignRootNode(node, domstartY, maxRootNodeY) {
		//take the rootnode with max positionY
		//set positionY of all the root nodes of other domains equal to max(positionY)
		node.positionY = maxRootNodeY - domstartY + node.positionY;
		var children = getChildren(node.nodeid,nodes, treelinks);
		children.forEach(function(child) {
			vertAlignRootNode(child, domstartY, maxRootNodeY);
		});
	}

	function initializeNodes(node, depth, domainindex, prevdomainmaxlevel) {
		//console.log("Initializing node ", node);
		node.positionY = -1;
		//console.log("positionY set to ", node.positionY);
		//node.positionX = depth + domainindex*distX*domainmaxlevel;
		node.positionX = depth + prevdomainmaxlevel*distX*domainindex;

		node.mod = 0;

		var children = getChildren(node.nodeid,nodes, treelinks);
		children.forEach(function(child) {
			initializeNodes(child,depth + distX,domainindex, prevdomainmaxlevel);
		});
	} //end function

	function calculateFinalPositions(node, modsum) {
		//console.log("Calculating Final Positions for node:", node);
		node.positionY += modsum;
		//console.log("positionY set to ", node.positionY);
		modsum += node.mod;

		var children = getChildren(node.nodeid,nodes, treelinks);

		children.forEach(function(child) {
			calculateFinalPositions(child, modsum);
		});

		if (children.length == 0) {
				node.width = node.positionX;
				node.height = node.positionY;
		} else {
			//node.width = children.OrderByDescending(p => p.Width).First().width;
			node.width = orderByDescendingWidth(children)[0].width;
			node.height = orderByDescendingWidth(children)[0].height;
		}

	} // end function

	//TODO: orders nodelist by width, returns ordered list
	function orderByDescendingWidth(children) {
		return children;
	}

	//https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/
	function calcInitNodeY(node) {
		//console.log("Calculating Initial Positions for node:", node.name);
		//console.log("lvlnode:",node);
		var children = getChildren(node.nodeid,nodes, treelinks);
		//console.log("children:", children);
		children.forEach(function(child) {
			//console.log("child:",child);
			calcInitNodeY(child);
		});


		var prevSibling = getPrevSibling(node);
		//console.log("prevSibling:", prevSibling);

		//if no children
		if (children.length == 0) {
			//console.log("no children for node:", node.name);
			//if there is a previous sibling
			if (prevSibling) {
				//console.log("has prevSibling");
				node.positionY = getPrevSibling(node).positionY + distY;
			} else { //if node is the first sibling/topmost node
				//console.log("no prevSiblings");
				node.positionY = 0;
			}
			//console.log("set positionY to:", node.positionY);
		} //end if no children
		else if (children.length == 1){
			//console.log("1 child code.. ");
			// if this is the first node in a set, set it's X value equal to it's child's X value

			if (!prevSibling) {
				node.positionY = 0;
				//console.log("positionY set to ", node.positionY);
			} else {
				node.positionY = prevSibling.positionY + distY;
				//console.log("positionY set to ", node.positionY);
				node.mod = children[0].positionY;
				//console.log("mod changed to:", node.mod);
			}
		} //end if one child
		else { //if more than one child
			//console.log("more than one child of node:", node.name);

			//console.log("Several children code.. ", node);
			var leftChild = getLeftMostChild(node);
			var rightChild = getRightMostChild(node);
			var mid = (leftChild.positionY + rightChild.positionY) / 2;
			//console.log("leftmost child: ",leftChild);
			//console.log("rightmost child: ",rightChild);
			//console.log("mid: ",mid);

			//console.log("prevSibling:", prevSibling);

			if (!prevSibling) { //if node is leftmost(upmost)
				//console.log("no previous siblings for node:", node.name);
				node.positionY = mid;
				//console.log("positionY set to ", node.positionY);
			} else {
				node.positionY = prevSibling.positionY + distY;
				//console.log("positionY set to ", node.positionY);
				node.mod = node.positionY - mid;
				//console.log("set positionY to:", node.positionY);
				//console.log("set mod to:", node.mod);
			}
		} //end if several children

		/*if (node.Children.Count > 0 && !node.IsLeftMost())
		{
				// Since subtrees can overlap, check for conflicts and shift tree right if needed
				CheckForConflicts(node);
		}*/
		// Since subtrees can overlap, check for conflicts and shift tree right if needed
		if (children.length > 0 && prevSibling != null)
			checkForConflicts(node);

	} //end function

	function checkForConflicts(node) {
		//console.log("Checking for conflicts ....", node);
		var minDistance = distY;
		var shiftValue = 0;

		var nodeContour = {}; //create new dictionary
		nodeContour = getLeftContour(node, 0, nodeContour);

		var sibling = getLeftMostSibling(node);
		//console.log("LeftMostSibling:", sibling);

		while (sibling != null && sibling != node) {
			var siblingContour = {};
			siblingContour = getRightContour(sibling, 0, siblingContour);

			/*console.log("nodeContour:", nodeContour);
			console.log("siblingContour:", siblingContour);*/

			var siblingkeysmax = Object.keys(siblingContour).reduce(function(a, b){ return siblingContour[a] > siblingContour[b] ? a : b });
			var nodekeysmax = Object.keys(nodeContour).reduce(function(a, b){ return nodeContour[a] > nodeContour[b] ? a : b });

			/*console.log("siblingkeysmax:", siblingkeysmax);
			console.log("nodekeysmax:", nodekeysmax);
			console.log("init level:", node.positionX + distX);*/
			//for (var level = node.positionX + distX; level <= Math.min(siblingkeysmax, nodekeysmax); level++) {
			for (var level = node.positionX + distX; level <= siblingkeysmax; level++) {
				//console.log("level:", level);
				var distance = nodeContour[level] - siblingContour[level];
				if (distance + shiftValue < minDistance)
						shiftValue = minDistance - distance;
			}

			if (shiftValue > 0) {
					 node.positionY += shiftValue;
					 node.mod += shiftValue;

					 centerNodesBetween(node, sibling);

					 shiftValue = 0;
			 }

			 sibling = getNextSibling(sibling);

		} //end while
	} //end function

	function centerNodesBetween(leftNode, rightNode) {
		//var leftIndex = leftNode.Parent.Children.IndexOf(rightNode);
		var leftParent = getParent(leftNode.nodeid, nodes, treelinks);
		//var rightParent = getParent(rightNode.nodeid, nodes, treelinks);
		var leftParentChildren = getChildren(leftParent.nodeid, nodes, treelinks);
		//var rightParentChildren = getChildren(rightParent.nodeid, nodes, treelinks);
		var leftIndex = leftParentChildren.indexOf(rightNode);
		var rightIndex = leftParentChildren.indexOf(leftNode);

		var numNodesBetween = (rightIndex - leftIndex) - 1;

		if (numNodesBetween > 0) {
			var distanceBetweenNodes = (leftNode.positionY - rightNode.positionY) / (numNodesBetween + 1);
			var count = 1;
			for (var i = leftIndex + 1; i < rightIndex; i++){
				var middleNode = leftParentChildren[i];

				var desiredX = rightNode.positionY + (distanceBetweenNodes * count);
				var offset = desiredX - middleNode.positionY;
				middleNode.positionY += offset;
				middleNode.mod += offset;

				count++;
			}
			checkForConflicts(leftNode);
		}
	} //end function

	function checkAllChildrenOnScreen(node) {
		//console.log("Checking all children on screen ....", node);
		var nodeContour = {}; //create new dictionary
		nodeContour = getLeftContour(node, 0, nodeContour);
		//console.log("nodeContour:", nodeContour);

		var shiftAmount = 0;

		for (var key in nodeContour) {
				if (nodeContour.hasOwnProperty(key)) {
					// do stuff
					if (nodeContour[key] + shiftAmount < 0)
						shiftAmount = (nodeContour[y] * -1);
				}
		}

		if (shiftAmount > 0) {
				node.positionY += shiftAmount;
				//console.log("positionY set to ", node.positionY);
				node.mod += shiftAmount;
		}
		/*var nodeContour = new Dictionary<int, float>();
		GetLeftContour(node, 0, ref nodeContour);
		float shiftAmount = 0;
		foreach (var y in nodeContour.Keys)
		{
				if (nodeContour[y] + shiftAmount < 0)
						shiftAmount = (nodeContour[y] * -1);
		}

		if (shiftAmount > 0)
		{
				node.X += shiftAmount;
				node.Mod += shiftAmount;
		}
		*/
	}

	function getLeftMostSibling(node) {

		var parentNode = getParent (node.nodeid, nodes, treelinks);
		return getLeftMostChild(parentNode);
	}

	function getLeftContour(node, modsum, values) {

		//  console.log("getLeftContour for node:", node);
		//if values has key node.positionX
		//console.log("     values.hasOwnProperty(",node.positionX, ") = ", values.hasOwnProperty(node.positionX));
		if (!values.hasOwnProperty(node.positionX)){
			//console.log("   no key..")
			//console.log("    node.positionY:",node.positionY, " + modsum:", modsum);
			values[node.positionX] = node.positionY + modsum;
		} else {
			/*console.log("    key exists, get minimim between");
			console.log("    values[node.positionX]:",values[node.positionX]);
			console.log("    and node.positionY:",node.positionY, " + modsum:", modsum);*/
			values[node.positionX] = Math.min(values[node.positionX], node.positionY + modsum);
		}

		//console.log("values after:", values);

		modsum += node.mod;

		var children = getChildren(node.nodeid,nodes, treelinks);

		children.forEach(function(child) {
			getLeftContour(child, modsum, values);
		});
		return values;
		/*if (!values.ContainsKey(node.Y))
				values.Add(node.Y, node.X + modSum);
		else
				values[node.Y] = Math.Min(values[node.Y], node.X + modSum);

		modSum += node.Mod;

		foreach (var child in node.Children)
		 {
				 GetLeftContour(child, modSum, ref values);
		 }
		*/
	} //end function

	function getRightContour(node, modsum, values) {
		//if values has key node.positionX
		if (!values.hasOwnProperty(node.positionX)){
			values[node.positionX] = node.positionY + modsum;
		} else {
			values[node.positionX] = Math.max(values[node.positionX], node.positionY + modsum);
		}

		//console.log("values after:", values);

		modsum += node.mod;

		var children = getChildren(node.nodeid,nodes, treelinks);

		children.forEach(function(child) {
			getRightContour(child, modsum, values);
		});
		return values;
	} //end function

	function getLeftMostChild(node) {
		//console.log("getLeftMostChild for node :", node);
		var children = getChildren(node.nodeid,nodes, treelinks);
		//console.log("first(leftmost) child :", children[0]);
		return children[0];
	}

	function getRightMostChild(node) {
		var children = getChildren(node.nodeid,nodes, treelinks);
		return children[children.length-1];
	}

	//get previous sibling
	function getPrevSibling(node) {
		//console.log("getPrevSibling function for node...", node.name);
		var parentNode = getParent (node.nodeid, nodes, treelinks);
		//console.log("   parentNode:", parentNode);
		if (parentNode) {
			var siblings =  getChildren (parentNode.nodeid, nodes, treelinks);
			//console.log("siblings:", siblings);
			var nodeindex = siblings.indexOf(node);
			if (nodeindex == 0) //it means that it is the topmost sibling
				return null;
			else {
				return siblings[nodeindex - 1];
			}
		}
	}

	function getNextSibling(node) {
		var parentNode = getParent (node.nodeid, nodes, treelinks);
		//console.log("parentNode:", parentNode);
		if (parentNode) {
			var siblings =  getChildren (parentNode.nodeid, nodes, treelinks);
			//console.log("siblings:", siblings);
			var nodeindex = siblings.indexOf(node);
			if (nodeindex == siblings.length-1) //it means that it is the rightmost/lowest sibling
				return null;
			else {
				return siblings[nodeindex + 1];
			}
		}
	}

	//takes an array of nodes as an input, returns the maximum level for that array
	function getMaxLevels(domainObj) {
		//console.log("maxlevel domainnodes:", domainObj.nodes);
		var nodes = domainObj.nodes;
		maxlevel = nodes[0].level;
		for (j = 0; j < nodes.length; j++) {
			if (nodes[j].level > maxlevel)
				maxlevel = nodes[j].level;
		}
		return maxlevel;
	}

	//MAIN FLOW STARTS HERE
	var domarray = getDomainArray();

	//console.log('domainarray:', domarray);

	calcDomainPositionsX(domarray);

	//calcDomainPositionsY(domarray);

	var sortedDomarray = sortDomainArray(domarray);

	console.log("sorted domarray:", sortedDomarray);

	calcNodePositionsY(sortedDomarray);

	//requirements to data:WHY?
	//-nodes sorted by level, starting from lowest levels
	//in the file, nodes have to be sorted by ids, because id is assigned sequentially

	//DOMAIN LABELS
	var hsep = 100; //horizontal separation between levels within one domain
	const domainLabelsY = -50;
	var domainLabelElem = svgGroup.selectAll("g domainLabels")
												.data(sortedDomarray)

	var domainLabelElemEnter = domainLabelElem.enter()

	domainLabelElemEnter.append("text")
	.attr("dx", function(d, i) {
			//return viewerWidth - hsep*(maxlevel - d.level);
			var domain = d.domain;
			var level = d.level;
			var domainstartX = d.startX;
			//console.log("Label Enter D:",d);
			//console.log("maxlevel + hsep:",d.maxlevel," + ", hsep);
			//d.positionX = viewerWidth - domainstartX - hsep*(domainmaxlevel - nodelevel);
			return domainstartX + d.maxlevel * hsep;
			//console.log("domainstartX:",  domainstartX, "posX:",  d.positionX );
	})
	.attr("dy", domainLabelsY)
	.attr("class", "domainLabels")
	.text(function(d){
			//return d.name + " pos:" + d.positionY + " spaceY:" + d.spaceY})
			return d.name })
	.attr("stroke", "black")
	.attr("stroke-width", 1)
	.style("text-transform", "uppercase")
	.style("font-size", 24);
	/*.attr("id", function(d, i) {
			return d.nodeid
	})
	.attr("class", "labels")
	.text(function(d){
			//console.log(d);
			//return d.name + " pos:" + d.positionY + " spaceY:" + d.spaceY})
			return d.name })
	.attr("stroke", "black")
	.attr("stroke-width", 1);*/

	var elem = svgGroup.selectAll("g circles")
			.data(nodes)

	/*Create and place the "blocks" containing the circle and the text */
	var elemEnter = elem.enter()
			//.attr("transform", function(d){return "translate("+d.x+",80)"})

	function getAvgPositionY(children) {
		sum = 0;
		//for each child in children
		for (j = 0; j < children.length; j++) {
			child = children[j];
			//console.log("child: ", child.name, "posY:", child.positionY);
			sum = sum + child.positionY;
		}
		avg = sum / children.length;
		//console.log("average posY: ", avg);
		return avg
	}

	function getDomainLevelSize(domain,level,domarray) {
		var result = 0;
		for (var j = 0; j < domarray.length; j++) {
			if (domain == domarray[j].name) {
				//iterate within that domain and count how many nodes are there at that level
				for (var k = 0; k < domarray[j].nodes.length; k++) {
					if (level == domarray[j].nodes[k].level) {
						result = result + 1;
					}
				}
			}
		}
		//console.log("domain:", domain, "level:", level, "number of nodes: ", result);
		return result;
	}

	function getDomainElement(domain,domarray) {
		for (var j = 0; j < domarray.length; j++) {
			if (domain == domarray[j].name) {
				//iterate within that domain and count how many nodes are there at that level
					//console.log("return:", domarray[j]);
					return domarray[j];
			}
		}
	} //end function

	//given domain element and needed nodeID, returns index for that nodeID in the domain.nodes array
	function getNodeIndex(nodeid,domainelement) {
		//console.log("domainelement.nodes:", domainelement.nodes);
		for (var j = 0; j < domainelement.nodes.length; j++) {
			//console.log("domainelement.nodes[j].id:", domainelement.nodes[j].nodeid, "nodeid:", nodeid);
			if (nodeid == domainelement.nodes[j].nodeid) {
				//iterate within that domain and count how many nodes are there at that level
					//console.log("return nodeindex:", j);
					return j;
			}
		}
	} //end function

	//console.log(nodes);
	maxlevel = 5;
	var lvl1counter = 0;


			//http://bl.ocks.org/timpulver/d3fefb4fac2510cf81a8
		function clickcancel() {
				var event = d3.dispatch('click', 'dblclick');

				function cc(selection) {
					//console.log(selection);
					var down,
					tolerance = 5,
					last,
					wait = null;
					// euclidean distance
					function dist(a, b) {
						return Math.sqrt(Math.pow(a[0] - b[0], 2), Math.pow(a[1] - b[1], 2));
					}
					selection.on('mousedown', function() {
						down = d3.mouse(document.body);
						last = +new Date();
					});
					selection.on('mouseup', function() {
						if (dist(down, d3.mouse(document.body)) > tolerance) {
							return;
						} else {
							if (wait) {
								window.clearTimeout(wait);
								wait = null;
								event.dblclick(d3.event);
							} else {
								wait = window.setTimeout((function(e) {
									return function() {
										event.click(e);
										wait = null;
									};
								})(d3.event), 300);
							}
						}
					});
				};
				return d3.rebind(cc, event, 'on');
		}

		var cc = clickcancel();

		var circle = elemEnter.append("circle")
		.attr("class", "nodes")
		.attr("id", function(d, i) {
			return i
		})
		.attr("cx", function(d, i) {
			//DOMAINS - WORK HERE
			//console.log("posX:",viewerWidth, hsep*d.level);
			//d.positionX = viewerWidth - hsep*(maxlevel - d.level);
			nodedomain = d.domain;
			nodelevel = d.level;
			domainstartX = getDomainElement(nodedomain,domarray).startX;
			domainmaxlevel = getDomainElement(nodedomain,domarray).maxlevel;
			//d.positionX = viewerWidth - domainstartX - hsep*(domainmaxlevel - nodelevel);

			//console.log("domainstartX:",  domainstartX, "posX:",  d.positionX );
			return d.positionX;
		})
		.attr("cy", function(d, i) {
			d.children = getChildren(i, nodes, treelinks);
			d.parent = getParent(i, nodes, treelinks);
			return d.positionY;

		})
		.on("mouseover", handleMouseOver) //http://bl.ocks.org/WilliamQLiu/76ae20060e19bf42d774
		.on("mouseout", handleMouseOut)
		.call(cc)
		//.on("dbclick",handleDoubleClick)
		//.on("click", handleMouseClick)
		.attr("r", radius)
		.attr("fill", "lightsteelblue")
		.attr("stroke", "steelblue")
		.attr("stroke-width", function(d) {
			return d/2;
		})
		;

		cc.on('click', handleMouseClick); //in this case not data, but mouseevent is passed
		cc.on('dblclick', handleDoubleClick); //in this case not data, but mouseevent is passed

		//http://bl.ocks.org/WilliamQLiu/76ae20060e19bf42d774
		// Create Event Handlers for mouse
		function handleDoubleClick(d, i) {
			console.log("double click event");
			alert("node was double clicked");
		}

		function handleMouseOver(d, i) {  // Add interactivity

					//get nodeid = i, index in the nodes list from json
					//console.log(d, "index:", i, "tracingDictFull:", tracingDictFull[i]);

					//find all nodes that share traces with the current node
					//WE USE OTHER VARIANT HERE FOR TRACINGDICTTWO
					curtrace = getNodeIDsFromTraceArray(tracingDictFull[i], nodes);
					curtracetwo = getNodeIDsFromTrace(tracingDictFullTwo[i]);
					/*console.log("curtrace:", curtrace);
					console.log("curtracetwo:", curtracetwo);
					console.log("tracingDictFull[i]:", tracingDictFull[i]);
					console.log("tracingDictFullTwo[i]:", tracingDictFullTwo[i]);
					console.log("sortedTracingDictFullTwo[i]:", sortedTracingDictFullTwo[i]);*/
					//var fulltrace = getFullTracingDict([13,47]);

					//find nodes from trace, highlight them
					svgGroup.selectAll(".nodes")
									.filter(function(d,i){
										//return d3.select(this).attr('id') > 4;
										//console.log("selected:", d);
										currentID = d3.select(this).attr('id');
										//console.log("currentID:", currentID);
										return curtrace.indexOf(parseInt(currentID)) != -1; //add to selection only if the id of the current node is in the tracelist for the clicked node
										})
									.attr("fill", function(d) {
											if (d3.select(this).attr('fill') == "red") {
												return "red";
											} else {
												return "orange";
											}
										});
						//r: radius * 2

					//find edges where source and target are both in tracingDict[i]
					svgGroup.selectAll(".edges")
									.filter(function(d,i){
										//console.log("filtering edges...");
										edgeSource = d3.select(this).attr('source');
										edgeTarget = d3.select(this).attr('target');
										return (curtrace.indexOf(parseInt(edgeSource)) != -1 && curtrace.indexOf(parseInt(edgeTarget)) != -1);
									})
									.attr({
									stroke: "orange"
					});

					//IMPLEMENT DOMAINS, ENABLE TRACEBILITY BETWEEN DOMAINS

				}



	function handleMouseOut(d, i) {
			// Use D3 to select element, change color back to normal
			/*d3.select(this).attr({
				fill: "lightsteelblue",
				r: radius
			});*/ //THIS IS FOR ONE, CURRENT ELEMENT ONLY
			//find nodes from trace, highlight them
			svgGroup.selectAll(".nodes")
			.attr("fill", function(d) {
					if (d3.select(this).attr('fill') == "red") {
						return "red";
					} else {
						return "lightsteelblue";
					}
				});

			svgGroup.selectAll(".edges").attr({
				stroke: "lightsteelblue"
			});

			// Select text by id and then remove
			//d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
		}



	//Collapse on click
	//http://bl.ocks.org/d3noob/8375092
	//when collapse - store children before collapsing to _children field
	//when expand - bring back children from _children
	function handleMouseClick(d, i) {

	/* THIS IS FROM THE ORIGINAL VERSION, REMOVED FOR MTURK PURPOSES
	ddata = d3.select(d.srcElement).data()[0];
	console.log("clicked object:", ddata);
	if (!ddata.collapsed)
		collapse(ddata);
	else
		decollapse(ddata);
	*/
	var clickedElem = d3.select(d.srcElement);
	var clickedElemData = clickedElem.data()[0];
	console.log("clicked object:", clickedElemData);

	if (clickedElem.attr("fill") == "red") { //if already clicked
		//repaint back
		clickedElem.attr({fill: "orange"});
		//remove from the list of selected nodes
		var index = clickedElemList.indexOf(clickedElem);
		if (index > -1) {
			clickedElemList.splice(index, 1);
		}
	} else {
		//paint as highlighted
		clickedElem.attr({fill: "red"});
		//add to the list of selected nodes
		clickedElemList.push(clickedElem);
	}

	if (taskType >= 4) { //for last task types we want to keep not one, but many answer nodes
		//return the whole list
		//console.log("clicked list:", clickedElemList);
	} else {
		//return the last element, if any
		if (clickedElemList.length > 0) {
			//console.log("clicked list last elem:", clickedElemList[clickedElemList.length - 1].data()[0]);
		} else {
			//console.log("no items in clicked list");
		}
	}

} //end function handleMouseClick

function collapse(nodeSelection) {
	//console.log("current nodeSelection: ", nodeSelection);
		if (nodeSelection.children) {
			nodeSelection._children = nodeSelection.children;
			nodeSelection._children.forEach(collapse);
			nodeSelection._children.forEach(hideInParent);
			nodeSelection.children = null;
			nodeSelection.collapsed = true;
		}
}

function decollapse(nodeSelection) {
	//console.log("decollapse");
	//console.log("current nodeSelection: ", nodeSelection, "collapsed", nodeSelection.collapsed);
		if (nodeSelection._children) {
			nodeSelection.children = nodeSelection._children;
			nodeSelection.children.forEach(decollapse);
			nodeSelection.children.forEach(setCoordsToPrevPos);
			nodeSelection._children = null;
			nodeSelection.collapsed = false;
		}
}

function setCoordsToPrevPos(nodeSelection) {
	//console.log("set coordinates to previous position");

	//bring back nodes to the last saved position
	var currentNodeSelection =  svgGroup.selectAll(".nodes")
					.filter(function(d,i){
						return d.nodeid == nodeSelection.nodeid;
					})

	//lastPosX = currentNodeSelection.attr("lastPosX");
	//lastPosY = currentNodeSelection.attr("lastPosY");

	console.log("lastPosX:", lastPosX);
	console.log("lastPosY:", lastPosY);

	currentNodeSelection.attr("fill", "lightsteelblue")
											.attr("cx", lastPosX)
											.attr("cy", lastPosY)
											.transition();

	currentNodeSelection.transition()
											.attr("visibility", "visible");

	var labelSelection = svgGroup.selectAll(".labels")
																				.filter(function(d,i){
																				return d.nodeid == nodeSelection.nodeid;
																				//console.log("currentID:", currentID, " is in children:", openChildrenIDs.indexOf(currentID.toString()) );
																		})
																			 .attr("visibility", "visible");

	//hide edges - choose all paths where "target" attribute is within openChildrenIDs
	 var edgeChildrenSelection = svgGroup.selectAll(".edges")
																			 .filter(function(d,i){
																					 currentTarget = d3.select(this).attr('target');
																					 //console.log("currentTarget:", currentTarget, " is in children:", openChildrenIDs.indexOf(currentTarget.toString()) );
																					 return currentTarget == nodeSelection.nodeid;
																			 })
																			 .attr("visibility", "visible");

}

function hideInParent(nodeSelection) {
	//
	//console.log("hideInParent", nodeSelection);
	//get parent nodes coordinates
	var parentSelection = svgGroup.selectAll(".nodes")
					.filter(function(d,i){
						currentID = parseInt(d3.select(this).attr('id'));
						//console.log("currentID:", currentID, " parentID:", nodeSelection.parent.nodeid);
						return currentID == nodeSelection.parent.nodeid;
					});

	//console.log("parentSelection: ",parentSelection);
	parentCX = parentSelection.attr("cx");
	parentCY = parentSelection.attr("cy");

	//set their coordinates to parent coordinates
	var currentNodeSelection =  svgGroup.selectAll(".nodes")
					.filter(function(d,i){
						return d.nodeid == nodeSelection.nodeid;
					})

	//console.log("currentNodeSelection: ",currentNodeSelection);

	//save last position
	currentPosX = currentNodeSelection.attr("cx");
	currentPosY = currentNodeSelection.attr("cy");

	//console.log("currentPosX: ",currentPosX);
	//console.log("currentPosY: ",currentPosY);

	/*currentNodeSelection.transition()
											.attr("cx", parentCX)
											.attr("cy", parentCY)
											.attr("lastPosX", currentPosX)
											.attr("lastPosY", currentPosY); */

	currentNodeSelection.attr("lastPosX", currentPosX)
	.attr("lastPosY", currentPosY)
	.transition()
	.attr("cx", parentCX)
	.attr("cy", parentCY);


	currentNodeSelection.transition()
										.delay(100)
										.attr("visibility", "hidden");
	//                    .transition();

 //hide labels
 var labelSelection = svgGroup.selectAll(".labels")
																			 .filter(function(d,i){
																			 return d.nodeid == nodeSelection.nodeid;
																			 //console.log("currentID:", currentID, " is in children:", openChildrenIDs.indexOf(currentID.toString()) );
																	 })
																			.attr("visibility", "hidden");

 //hide edges - choose all paths where "target" attribute is within openChildrenIDs
	var edgeChildrenSelection = svgGroup.selectAll(".edges")
																			.filter(function(d,i){
																					currentTarget = d3.select(this).attr('target');
																					//console.log("currentTarget:", currentTarget, " is in children:", openChildrenIDs.indexOf(currentTarget.toString()) );
																					return currentTarget == nodeSelection.nodeid;
																					//return currentTarget == 63;
																			})
																			.attr("visibility", "hidden");
}

	//DRAWING EDGES
		//http://bl.ocks.org/milkbread/5902470
		links.forEach(function(link){
				//console.log(link, link.source, nodes[link.source].name, nodes[link.source].positionX);
				var lineData = [ { "x": 1,   "y": 5},  { "x": 20,  "y": 20}];//arbitrary
				lineData[0].x = nodes[getNodeIndexByName(link.source)].positionX
				lineData[0].y = nodes[getNodeIndexByName(link.source)].positionY
				lineData[1].x = nodes[getNodeIndexByName(link.target)].positionX
				lineData[1].y = nodes[getNodeIndexByName(link.target)].positionY
				//console.log("lineData", lineData);

			 var diagonal = d3.svg.diagonal()
			 .projection(function(d) { return [d.y, d.x]; });

//https://github.com/d3/d3-shape/issues/27
			 function linkHorizontal(d) {
				 return "M" + d[0].x + "," + d[0].y
		+ "C" + d[0].x +  "," + (d[0].y + d[1].y) / 2
		+ " " + d[1].x + "," + (d[0].y + d[1].y) / 2
		+ " " + d[1].x + "," + d[1].y;
			}

			function linkVertical(d) {
				return "M" + d[0].x + "," + d[0].y
						+ "C" + (d[0].x + d[1].x) / 2 + "," + d[0].y
						+ " " + (d[0].x + d[1].x) / 2 + "," + d[1].y
						+ " " + d[1].x + "," + d[1].y;
			}

			 var lineGraph = elemEnter.append("path")
																	 .attr('d', linkVertical(lineData)) //THIS IS BEING TESTED
																	 //.attr("id", "source:" + link.source + "," + "target:" + link.target)
																	 .attr("source", getNodeIndexByName(link.source))
																	 .attr("target", getNodeIndexByName(link.target))
																	 .attr("class", "edges")
																	 .attr("stroke", "lightsteelblue")
																	 .attr("stroke-width", 1)
																	 .attr("fill", "none");

		}); //foreach

		//LABELS
		//https://stackoverflow.com/questions/13615381/d3-add-text-to-circle
		/* Create the text for each block */
		elemEnter.append("text")
		.attr("dx", function(d, i) {
				//console.log("Label Enter D:",d);
				//return viewerWidth - hsep*(maxlevel - d.level);
				nodedomain = d.domain;
				nodelevel = d.level;
				domainstartX = getDomainElement(nodedomain,domarray).startX;
				domainmaxlevel = getDomainElement(nodedomain,domarray).maxlevel;
				//d.positionX = viewerWidth - domainstartX - hsep*(domainmaxlevel - nodelevel);
				//console.log("domainstartX:",  domainstartX, "posX:",  d.positionX );
				return d.positionX + 5;
		})
		.attr("dy", function(d, i) {
				return d.positionY;
		})
		.attr("id", function(d, i) {
				return d.nodeid
		})
		.attr("class", "labels")
		.text(function(d){
				//console.log(d);
				//return d.name + ":" + d.nodeid})
				var returnstring = d.name;
				if (d.level == 1)
					returnstring = returnstring.toUpperCase();

				/*if (returnstring.length > 17)
					returnstring = returnstring.slice(0,17) + "\r\n" + returnstring.slice(17)
				*/
				return returnstring})
		.attr("stroke", "black")
		.attr("text-transform", "uppercase")
		.attr("stroke-width", 1);
}
</script>




</html>
