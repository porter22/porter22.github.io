<!DOCTYPE html>
<meta charset="utf-8">
<style type="text/css">
	.node {
    cursor: pointer;
  }
  .overlay{
      background-color:#EEE;
  }
  .node circle {
    fill: #fff;
    stroke: steelblue;
    stroke-width: 1.5px;
  }
  .node text {
    font-size:10px;
    font-family:sans-serif;
  }
  .link {
    fill: none;
    stroke: #ccc;
    stroke-width: 1.5px;
  }
  .additionalParentLink {
    fill: none;
    stroke: blue;
    stroke-width: 1.5px;
  }
  .templink {
    fill: none;
    stroke: red;
    stroke-width: 3px;
  }
  .ghostCircle.show{
      display:block;
  }
  .ghostCircle, .activeDrag .ghostCircle{
       display: none;
  }

	.trialDiv {
		display: none;
	}

	#responseButton {
		display: none;
	}
</style>
<body>
	<p>Instructions for the experiment.
		<a href="#" id="startExperiment">Start Experiment</a>
	</p>

		<div id="trial1" class="trialDiv">
			<p>Trial 1 text. </p>
    	<div id="tree-container1"></div>
		</div>

		<div id="trial2" class="trialDiv">
			<p>Trial 2 text. </p>
    	<div id="tree-container2"></div>
		</div>

		<div id="trial3" class="trialDiv">
			<p>Trial 3 text. </p>
    	<div id="tree-container3"></div>
		</div>

		<button type="button" id="responseButton">Response Button</button>

</body>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.0.0/d3.min.js"></script>
<script>

var json = {
	"nodes": [
		{ "name": "path detection", "level": 3, "domain": "requirements" },
		{ "name": "steering", "level": 3, "domain": "requirements" },
		{ "name": "obstacle avoidance", "level": 3, "domain": "requirements" },
		{ "name": "enable communication between subsystems", "level": 3, "domain": "requirements" },
		{ "name": "weight detection", "level": 3, "domain": "requirements" },
		{ "name": "thermal insulation", "level": 3, "domain": "requirements" },
		{ "name": "damping", "level": 3, "domain": "requirements" },
		{ "name": "compact sizing", "level": 3, "domain": "requirements" },
		{ "name": "delivery in 10 minutes", "level": 2, "domain": "requirements" },
		{ "name": "distance of 6 km", "level": 2, "domain": "requirements" },
		{ "name": "autonomous driving", "level": 2, "domain": "requirements" },
		{ "name": "capacity of 6 bottles", "level": 2, "domain": "requirements" },
		{ "name": "beer delivery", "level": 1, "domain": "requirements" },
		{ "name": "to store bottles 0", "level": 3, "domain": "functional" },
		{ "name": "to absorb impact 1", "level": 3, "domain": "functional" },
		{ "name": "to provide stable movement from A to B 2", "level": 3, "domain": "functional" },
		{ "name": "to reduce speed 3", "level": 3, "domain": "functional" },
		{ "name": "to provide energy 4", "level": 3, "domain": "functional" },
		{ "name": "to transmit power 5", "level": 3, "domain": "functional" },
		{ "name": "to store energy 6", "level": 3, "domain": "functional" },
		{ "name": "to control speed 7", "level": 3, "domain": "functional" },
		{ "name": "to control direction 8", "level": 3, "domain": "functional" },
		{ "name": "to control braking 9", "level": 3, "domain": "functional" },
		{ "name": "to interface between sensors and actors 10", "level": 3, "domain": "functional" },
		{ "name": "to display information 11", "level": 3, "domain": "functional" },
		{ "name": "to provide feedback 12", "level": 3, "domain": "functional" },
		{ "name": "to avoid obstacles 13", "level": 3, "domain": "functional" },
		{ "name": "to detect paths 14", "level": 3, "domain": "functional" },
		{ "name": "to detect load 15", "level": 3, "domain": "functional" },
		{ "name": "housing 16", "level": 2, "domain": "functional" },
		{ "name": "undercarriage 17", "level": 2, "domain": "functional" },
		{ "name": "power supply 18", "level": 2, "domain": "functional" },
		{ "name": "control unit 19", "level": 2, "domain": "functional" },
		{ "name": "HMI 20", "level": 2, "domain": "functional" },
		{ "name": "sensors 21", "level": 2, "domain": "functional" },
		{ "name": "robot 21x", "level": 1, "domain": "functional" },
		{ "name": "mechanical switch 22", "level": 4, "domain": "structural" },
		{ "name": "spring 23", "level": 4, "domain": "structural" },
		{ "name": "tape line 24", "level": 4, "domain": "structural" },
		{ "name": "tracking sensor 25", "level": 4, "domain": "structural" },
		{ "name": "box 26", "level": 3, "domain": "structural" },
		{ "name": "tray 27", "level": 3, "domain": "structural" },
		{ "name": "base plate 28", "level": 3, "domain": "structural" },
		{ "name": "labeling 29", "level": 3, "domain": "structural" },
		{ "name": "door with hinge 30", "level": 3, "domain": "structural" },
		{ "name": "lock 31", "level": 3, "domain": "structural" },
		{ "name": "foam or hemp 32", "level": 3, "domain": "structural" },
		{ "name": "wheels 33", "level": 3, "domain": "structural" },
		{ "name": "axle 34", "level": 3, "domain": "structural" },
		{ "name": "platform 35", "level": 3, "domain": "structural" },
		{ "name": "shaft 36", "level": 3, "domain": "structural" },
		{ "name": "coupler 37", "level": 3, "domain": "structural" },
		{ "name": "e-motor 38", "level": 3, "domain": "structural" },
		{ "name": "brakes 39", "level": 3, "domain": "structural" },
		{ "name": "arduino 40", "level": 3, "domain": "structural" },
		{ "name": "charging control unit 41", "level": 3, "domain": "structural" },
		{ "name": "solar panel 42", "level": 3, "domain": "structural" },
		{ "name": "battery pack 43", "level": 3, "domain": "structural" },
		{ "name": "wires/cables 44", "level": 3, "domain": "structural" },
		{ "name": "weight sensor 45", "level": 3, "domain": "structural" },
		{ "name": "ultrasonic sensor 46", "level": 3, "domain": "structural" },
		{ "name": "line tracker 47", "level": 3, "domain": "structural" },
		{ "name": "acoustic signal 48", "level": 3, "domain": "structural" },
		{ "name": "LCD with I2C 49", "level": 3, "domain": "structural" },
		{ "name": "housing 50", "level": 2, "domain": "structural" },
		{ "name": "undercarriage 51", "level": 2, "domain": "structural" },
		{ "name": "power supply 52", "level": 2, "domain": "structural" },
		{ "name": "control unit 53", "level": 2, "domain": "structural" },
		{ "name": "HMI 54", "level": 2, "domain": "structural" },
		{ "name": "sensors 55", "level": 2, "domain": "structural" },
		{ "name": "robot 56", "level": 1, "domain": "structural" }
	],
	"links": [
		{ "source": "beer delivery", "target": "delivery in 10 minutes" },
		{ "source": "beer delivery", "target": "distance of 6 km" },
		{ "source": "beer delivery", "target": "autonomous driving" },
		{ "source": "beer delivery", "target": "capacity of 6 bottles" },
		{ "source": "autonomous driving", "target": "path detection" },
		{ "source": "autonomous driving", "target": "steering" },
		{ "source": "autonomous driving", "target": "obstacle avoidance" },
		{ "source": "autonomous driving", "target": "enable communication between subsystems" },
		{ "source": "capacity of 6 bottles", "target": "weight detection" },
		{ "source": "capacity of 6 bottles", "target": "thermal insulation" },
		{ "source": "capacity of 6 bottles", "target": "damping" },
		{ "source": "capacity of 6 bottles", "target": "compact sizing" },
		{ "source": "robot 56", "target": "housing 50" },
		{ "source": "robot 56", "target": "undercarriage 51" },
		{ "source": "robot 56", "target": "power supply 52" },
		{ "source": "robot 56", "target": "control unit 53" },
		{ "source": "robot 56", "target": "HMI 54" },
		{ "source": "robot 56", "target": "sensors 55" },
		{ "source": "housing 50", "target": "box 26" },
		{ "source": "housing 50", "target": "tray 27" },
		{ "source": "housing 50", "target": "base plate 28" },
		{ "source": "housing 50", "target": "labeling 29" },
		{ "source": "housing 50", "target": "door with hinge 30" },
		{ "source": "housing 50", "target": "lock 31" },
		{ "source": "housing 50", "target": "foam or hemp 32" },
		{ "source": "undercarriage 51", "target": "wheels 33" },
		{ "source": "undercarriage 51", "target": "axle 34" },
		{ "source": "undercarriage 51", "target": "platform 35" },
		{ "source": "undercarriage 51", "target": "shaft 36" },
		{ "source": "undercarriage 51", "target": "coupler 37" },
		{ "source": "undercarriage 51", "target": "e-motor 38" },
		{ "source": "undercarriage 51", "target": "brakes 39" },
		{ "source": "control unit 53", "target": "arduino 40" },
		{ "source": "control unit 53", "target": "charging control unit 41" },
		{ "source": "power supply 52", "target": "solar panel 42" },
		{ "source": "power supply 52", "target": "battery pack 43" },
		{ "source": "power supply 52", "target": "wires/cables 44" },
		{ "source": "sensors 55", "target": "weight sensor 45" },
		{ "source": "sensors 55", "target": "ultrasonic sensor 46" },
		{ "source": "sensors 55", "target": "line tracker 47" },
		{ "source": "HMI 54", "target": "acoustic signal 48" },
		{ "source": "HMI 54", "target": "LCD with I2C 49" },

		{ "source": "robot 21x", "target": "housing 16" },
		{ "source": "robot 21x", "target": "undercarriage 17" },
		{ "source": "robot 21x", "target": "power supply 18" },
		{ "source": "robot 21x", "target": "control unit 19" },
		{ "source": "robot 21x", "target": "HMI 20" },
		{ "source": "robot 21x", "target": "sensors 21" },
		{ "source": "housing 16", "target": "to store bottles 0" },
		{ "source": "housing 16", "target": "to absorb impact 1" },
		{ "source": "undercarriage 17", "target": "to provide stable movement from A to B 2" },
		{ "source": "undercarriage 17", "target": "to reduce speed 3" },
		{ "source": "power supply 18", "target": "to provide energy 4" },
		{ "source": "power supply 18", "target": "to transmit power 5" },
		{ "source": "power supply 18", "target": "to store energy 6" },
		{ "source": "control unit 19", "target": "to control speed 7" },
		{ "source": "control unit 19", "target": "to control direction 8" },
		{ "source": "control unit 19", "target": "to control braking 9" },
		{ "source": "control unit 19", "target": "to interface between sensors and actors 10" },
		{ "source": "HMI 20", "target": "to display information 11" },
		{ "source": "HMI 20", "target": "to provide feedback 12" },
		{ "source": "sensors 21", "target": "to avoid obstacles 13" },
		{ "source": "sensors 21", "target": "to detect paths 14" },
		{ "source": "sensors 21", "target": "to detect load 15" },
		{ "source": "weight sensor 45", "target": "mechanical switch 22" },
		{ "source": "weight sensor 45", "target": "spring 23" },
		{ "source": "line tracker 47", "target": "tape line 24" },
		{ "source": "line tracker 47", "target": "tracking sensor 25" }
	],
	"traces": [
		{ "nodeids":"54,21" },
		{ "nodeids":"40,13" },
		{ "nodeids":"45,13" },
		{ "nodeids":"14,46" },
		{ "nodeids":"15,47" },
		{ "nodeids":"15,48" },
		{ "nodeids":"15,52" },
		{ "nodeids":"16,53" },
		{ "nodeids":"17,56" },
		{ "nodeids":"18,58" },
		{ "nodeids":"19,57" },
		{ "nodeids":"20,54" },
		{ "nodeids":"22,54" },
		{ "nodeids":"23,54" },
		{ "nodeids":"24,63" },
		{ "nodeids":"25,59" },
		{ "nodeids":"26,60" },
		{ "nodeids":"27,61" },
		{ "nodeids":"27,38" },
		{ "nodeids":"27,39" },
		{ "nodeids":"28,59" }

	]
}

var clickedElemList = [];
var curTrial = 1;
var nTrials = 4;
var taskType = 5;
var startTrialTime;
function buttonClicked() {
	var curTime = new Date();
	var rt = curTime - startTrialTime;
	console.log(rt);
	$('#trial' + curTrial).hide();
	curTrial++;
	//document.getElementById('tempStorage').innerHTML = curTrial;
	if (curTrial > nTrials) {
		$('#submitButton').show();
	} else {
		$('#trial' + curTrial).show();
		showTree(curTrial, taskType);
		startTrialTime = new Date();
	}
}

function showFirstTrial(){
	$('#trial1').show();
	$('#responseButton').show();
	showTree(curTrial, taskType);
	startTrialTime = new Date();
	$('#startExperiment').hide();
}

$('#startExperiment').click(showFirstTrial);
$('#responseButton').click(buttonClicked);

function showTree (curTrial, taskType) {

	//console.log(error);
	// size of the diagram
	var viewerWidth = $(document).width();
	var viewerHeight = $(document).height();

	// define the zoomListener which calls the zoom function on the "zoom" event constrained within the scaleExtents
	var zoomListener = d3.behavior.zoom().scaleExtent([0.1, 3]).on("zoom", zoom);

	/*//get current trial number
	var curTrialCounter = document.getElementById('tempStorage').innerHTML;

	console.log("curTrials:", curTrialCounter);*/
	// define the baseSvg, attaching a class for styling and the zoomListener
	var baseSvg = d3.select("#tree-container" + curTrial).append("svg")
			.attr("width", viewerWidth)
			.attr("height", viewerHeight)
			.attr("class", "overlay")
			.call(zoomListener);

	// Append a group which holds all nodes and which the zoom Listener can act upon.
	var svgGroup = baseSvg.append("g");

	function zoom() {
			svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
	}

	var radius = 10;

	var distY = 30;
	var distX = 200; //separation between levels within one domain

	var nodes = json.nodes;
	var treelinks = json.links;
	var traces = json.traces;

	var globaldomains = ["structural","functional","requirements"];

	//add IDs to nodes
	for (j = 0; j < nodes.length; j++) {
		nodes[j].nodeid = j;
	}

	console.log("initial nodes:", nodes);

	var userTraces = getTracesFromFile(); //global array of full traces
	//trace1: source, p1, p2, p3,..., target
	//trace2: source, p1, p2, p3,..., target
	//console.log("userTraces: ", userTraces);

	//dictionary, where key = nodeID, value = list of connected nodes from traces
	var tracingDictFull = getTracingDictFullArray(userTraces, nodes);

	//array of links from all traces
	var tracelinks = getLinksFromTraces(userTraces);
	//console.log("all tracelinks:", tracelinks);

	//console.log("all treelinks: ", treelinks);
	//we distinguish between hierarchical links and links that are generated from the traces
	//rewrite this so that it adds only links that are not present in treelinks
	var links = treelinks.concat(tracelinks);

	links = inverseLinks(links);
	//var links = mergeLinks(treelinks, tracelinks);

	//console.log("merged links: ", links);
	//inverse links, if their source is larger level, that target
	//and if within same domain
	function inverseLinks(links) {
		var resultlinks = [];
		for (var i = 0; i < links.length; i++) {
			source = getNodeIndexByName(links[i].source);
			target = getNodeIndexByName(links[i].target);
			//console.log("current link:", links[i]);
			if (nodes[source].domain == nodes[target].domain && nodes[source].level > nodes[target].level) {
				links[i].source = nodes[target].name;
				links[i].target = nodes[source].name;
				//console.log("link: " + links[i] + " have changed")
			}
		}
		return links;
	}

	//given full trace array, sorts by domains REQS - FUNCTIONS - STRUCTURE
	function sortByDomain(traceArray) {
		//console.log("sortByDomain..");
		//first, fill dict where key is domain name,
		//value is array of nodes in that domain
		var domaintraces = {};
		//var resultarray = [];
		for (var j = 0; j < traceArray.length; j++) {
				if (domaintraces[traceArray[j].domain] != null) {
					domaintraces[traceArray[j].domain].push(traceArray[j]);
				} else {
					domaintraces[traceArray[j].domain] = [];
					domaintraces[traceArray[j].domain].push(traceArray[j]);
				}
		}
		//console.log("domaintraces:", domaintraces);
		//second, go through global array of domain names with correct order,
		//create result array based on this order
		var resultarray = domaintraces[globaldomains[0]];
		for (var j = 1; j < globaldomains.length; j++) {
			//console.log("domaintraces[globaldomains[j]]", domaintraces[globaldomains[j]]);
			//console.log("globaldomains[j]", globaldomains[j]);
			resultarray = resultarray.concat(domaintraces[globaldomains[j]]);
		}
		resultarray.pop(); //HACK: remove last "undefined" element
		//console.log("sorted domaintraces:", resultarray);
		return resultarray;
	}

	//function that returns an array of source-targets from the traces
	function getLinksFromTraces(userTraces) {
		//console.log("getLinksFromTraces ... ");
		var tracelinks = [];
		for (var j = 0; j < userTraces.length; j++) {
			var fulltraceArray = userTraces[j];
			//console.log("fulltraceArray:", fulltraceArray);
			//sort by domains, so that edges go starting from right to left
			fulltraceArray = sortByDomain(fulltraceArray);
			//for each node in trace, create link from this node, to next one
			for (var k = 0; k < fulltraceArray.length - 1; k++) {
				var tracelink = {};
				tracelink.source = fulltraceArray[k].name;
				tracelink.target = fulltraceArray[k+1].name;
				tracelinks.push(tracelink);
			}
		}
		return tracelinks;
	}

	//takes an array of full traces,
	// returns a dict, where key = nodeID, value = list of connected nodes from traces
	function getTracingDictFullArray (userTraces, nodes) {
		//console.log("getTracingDictFullArray...");
		//console.log("fulltraceArray:", fulltraceArray);
		var resultarray = [];

		for (var j = 0; j < nodes.length; j++) {
			resultarray[j] = [];
			for (var k = 0; k < userTraces.length; k++) {
				var fulltraceArray = userTraces[k];
				//console.log("fulltraceArray:", fulltraceArray);
				var tracenodeids = getNodeIDsFromTrace(fulltraceArray);
				//console.log("tracenodeids:", tracenodeids);

				//if nodeid is in tracenodeid list, assign or push fullTraceArray
				if (tracenodeids.indexOf(nodes[j].nodeid) != -1) {
					//console.log("nodes[j]:", nodes[j], "is in tracenodeids", tracenodeids);
					//console.log("resultarray[j]", resultarray[j]);
					resultarray[j].push(fulltraceArray);
				}
			}
		}
		//console.log("resultarray:", resultarray);
		return resultarray;
	}

	//gets a trace, returns an array of nodeids
	function getNodeIDsFromTrace(fulltrace) {
		//console.log("getNodeIDsFromTrace...");
		//console.log("fulltrace...", fulltrace);
		var resultarray = [];
		for (var j = 0; j < fulltrace.length; j++) {
			resultarray.push(fulltrace[j].nodeid);
		}
		return resultarray;
	}

	//gets a trace array, returns an array of nodeids
	function getNodeIDsFromTraceArray(traceArray) {
		console.log("getNodeIDsFromTraceArray...");
		var resultarray = [];
		for (var j = 0; j < traceArray.length; j++) {
			for (var k = 0; k < traceArray[j].length; k++) {
				resultarray.push(traceArray[j][k].nodeid);
			}
		}
		return resultarray;
	}

	//takes strings of user defined traces from the file,
	//transforms them into array of full traces
	function getTracesFromFile () {
		var resultarray = [];
		for (var k = 0; k < traces.length; k++) {
				//take each trace and make it full
				tracenodes = traces[k].nodeids.split(",");
				//console.log("tracenodes:", tracenodes);
				var fulltrace = getFullTraceFromShortTrace(tracenodes);
				//console.log("fulltrace:", fulltrace);
				resultarray.push(fulltrace);
		}
		return resultarray;
	}

	//takes a user defined route in the form of array of two elements,
	//translates it to full route with all nodes along the route
	function getFullTraceFromShortTrace(traceArray) {
		//console.log("getFullTraceArray...");
		var fullTraceArray = [];
		//we assume that array is sorted
		for (var j = 0; j < traceArray.length; j++) {
			var curnode = traceArray[j];
			//console.log("current node:", curnode);
			var domroot = getDomainRoot(nodes[curnode], []);
			domroot.unshift(nodes[curnode]);
			//console.log("domroot:", domroot);
			//add all connected nodes within one domain to the overall tracing array
			fullTraceArray = fullTraceArray.concat(domroot);
		}
		//console.log("fullTraceArray: ", fullTraceArray);
		return fullTraceArray;
	}

	//returns an array of all the ancestors of that node within domain
	function getDomainRoot(node, resultarray) {
		//console.log("getDomainRoot for node:", node);
		//console.log("nodeid:", node.nodeid);
		var parent = getParent(node.nodeid, nodes, treelinks);
		//console.log("parent:", parent);
		if (parent != null) {
			//console.log("parent domain:", parent.domain,"node domain:", node.domain);
			if (parent.domain == node.domain) {
				resultarray.push(parent);
				//console.log("resultarray after push:", resultarray);
				resultarray = getDomainRoot(parent, resultarray);
			}
		}
		return resultarray;
	}

	function getDomainArray() {
		domarray = [];
		domnames = [];
		for (j = 0; j < nodes.length; j++) {
			domindex = domnames.indexOf(nodes[j].domain);
			if (domindex != -1) {
				domarray[domindex].nodes.push(nodes[j]);
		} else {
				domnames.push(nodes[j].domain);
				var domobj = {};
				domobj.name = nodes[j].domain;
				domobj.nodes = [];
				domobj.nodes.push(nodes[j]);
				domarray.push(domobj);
				//console.log("domnames:", domnames);
				//console.log("domarray:", domarray);
			}
		} //end for loop
		//console.log("domarray:", domarray);
		return domarray;
	}

	//sort domain array by levels, where each array element contains set of nodes for that level
	function sortDomainArray(domarray) {
		//console.log("inarray", domarray);
		var outarray = domarray;
			for (var j = 0; j < domarray.length; j++) {
				var domnodes = domarray[j].nodes;
				//create array with maxlevel number of dimensions
				var maxlvl = domarray[j].maxlevel;

				var resultarray = createNDimArray([maxlvl,1]);
				//console.log("resultarray:", resultarray);
				for (var k = 0; k < domnodes.length; k++) {
					var nodelevel =  domnodes[k].level;
					if (resultarray[nodelevel - 1] == null) {
						resultarray[nodelevel - 1] = [];//.push(domnodes[k]);
					} else {
						resultarray[nodelevel - 1].push(domnodes[k]);
					}
				}
				//remove first null element
				for (var k = 0; k < resultarray.length; k++)
					resultarray[k].shift();//removes first null element
				//console.log("domain:", domarray[j].name, "resultarray after", resultarray);
				outarray[j].nodes = resultarray;
			}
			//console.log("outarray", outarray);
			return outarray;
	}

	//stackoverflow.com/questions/12588618/javascript-n-dimensional-array-creation
	function createNDimArray(dimensions) {
	 var ret = undefined;
	 if(dimensions.length==1){
			ret = new Array(dimensions[0]);
			for (var i = 0; i < dimensions[0]; i++)
					ret[i]=null; //or another value
			return ret;
	 }
	 else{
			//recursion
			var rest = dimensions.slice(1);
			ret = new Array(dimensions[0]);
			for (var i = 0; i < dimensions[0]; i++)
					ret[i]=createNDimArray(rest);
			return ret;
	 }
	}

	//calculates starting positions X for each domain, adds maxlevel parameter for each domain
	function calcDomainPositionsX(domarray) {
		//for each domain, find maxlevel depths
		//find sum of levels for all domains
		//find separation between levels = totalwidth/sum of levels
		sum = 0;
		//console.log("domain:", domarray);
		//for(var domain in domaindict) {
		for (var j = 0; j < domarray.length; j++) {

			var maxlevel = getMaxLevels(domarray[j]);
			//console.log("domain:", domain, "maxlevel:", maxlevel);
			domarray[j].maxlevel = maxlevel;
			//console.log("domain:", domarray[j].name, "maxlevel:", domarray[j].maxlevel);
			// do something with "key" and "value" variables
			sum = sum + maxlevel;
		}

		sepX = viewerWidth / sum;
		console.log("viewerWidth:", viewerWidth, "sepX:", sepX, "total levels:", sum);

		//assign startX to each domain
		domarray[0].startX = 0;
		for (var j = 1; j < domarray.length; j++) {
			domarray[j].startX = domarray[j-1].startX + sepX * domarray[j-1].maxlevel;
			//console.log("j:", j, "domarray[j-1].startX:", domarray[j-1].startX);
		}

		}//end function

		/*function calcDomainPositionsY(domarray) {
			//assign startY to level 1 nodes
			for (var j = 0; j < domarray.length; j++) {
				var level1nodes = 0;

				for (var k = 0; k < domarray[j].nodes.length; k++) {
					if (domarray[j].nodes[k].level == 1) {
						//count level 1 nodes for this domain
						level1nodes = level1nodes + 1;
					}
				}

				for (var k = 0; k < domarray[j].nodes.length; k++) {
					if (domarray[j].nodes[k].level == 1) {
						//spaceY - is a height available for each nodes descendants
						domarray[j].nodes[k].spaceY = viewerHeight / level1nodes;
					}
				}
			}

		//console.log("domarray final:", domarray);
	}//end function*/

	//main function that determines Y positions of nodes
	//based on https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/
	function calcNodePositionsY(domarray) {
		//nodeposY for first level = viewerHeight / nodeslength for that level and that domain
		//nodeposY for next levels = parent.spaceY / nodeslength for that level
		//where parent.spaceY - height available for that parent
		//console.log("Calculating Y positions for nodes...");

		//for (var j = 0; j < domarray.length; j++) {
		var maxRootNodeY = 0;
		var rootNodes = [];

		for (var j = 0; j < domarray.length; j++) { //CHANGE FOR 0 WHEN DONE WITH TESTING ONE DOMAIN
			var rootNode = domarray[j].nodes[0][0];

			//console.log("initial root:", rootNode);
			var prevdommaxlevel = 0; //max level of the previous domain
			if (j > 0)
				prevdommaxlevel = domarray[j-1].maxlevel

			initializeNodes(rootNode,0,j, prevdommaxlevel);

			//console.log("initialized root:", rootNode);

			// assign initial X and Mod values for nodes
			calcInitNodeY(rootNode); //firstwalk

			//console.log("Calculating Initial Positions Completed -----------------------");
			//console.log(rootNode);
			// ensure no node is being drawn off screen
			checkAllChildrenOnScreen(rootNode);

			// assign final X values to nodes
			calculateFinalPositions(rootNode, 0);

			//find max positionY for root nodes for later vertical alignment of trees
			if (rootNode.positionY > maxRootNodeY)
				maxRootNodeY = rootNode.positionY;

			rootNodes.push(rootNode);
		}

			for (var j = 0; j < rootNodes.length; j++) {
				//TODO: write function that vertically centers trees for each domain
				console.log("root node:", rootNodes[j]);
				var domstartY = rootNodes[j].positionY;
				vertAlignRootNode(rootNodes[j], domstartY, maxRootNodeY);

			}
		//console.log("domarray after spaceY:", domarray);
	}// end function

	//vertically centers trees for each domain
	function vertAlignRootNode(node, domstartY, maxRootNodeY) {
		//take the rootnode with max positionY
		//set positionY of all the root nodes of other domains equal to max(positionY)
		node.positionY = maxRootNodeY - domstartY + node.positionY;
		var children = getChildren(node.nodeid,nodes, treelinks);
		children.forEach(function(child) {
			vertAlignRootNode(child, domstartY, maxRootNodeY);
		});
	}

	function initializeNodes(node, depth, domainindex, prevdomainmaxlevel) {
		//console.log("Initializing node ", node);
		node.positionY = -1;
		//console.log("positionY set to ", node.positionY);
		//node.positionX = depth + domainindex*distX*domainmaxlevel;
		node.positionX = depth + prevdomainmaxlevel*distX*domainindex;
		console.log("node:", node);
		console.log("  depth:", depth);
		console.log("  domainindex:", domainindex);
		console.log("  prevdomainmaxlevel:", prevdomainmaxlevel);
		console.log("  positionX:", node.positionX);

		node.mod = 0;

		var children = getChildren(node.nodeid,nodes, treelinks);
		children.forEach(function(child) {
			initializeNodes(child,depth + distX,domainindex, prevdomainmaxlevel);
		});
	} //end function

	function calculateFinalPositions(node, modsum) {
		//console.log("Calculating Final Positions for node:", node);
		node.positionY += modsum;
		//console.log("positionY set to ", node.positionY);
		modsum += node.mod;

		var children = getChildren(node.nodeid,nodes, treelinks);

		children.forEach(function(child) {
			calculateFinalPositions(child, modsum);
		});

		if (children.length == 0) {
				node.width = node.positionX;
				node.height = node.positionY;
		} else {
			//node.width = children.OrderByDescending(p => p.Width).First().width;
			node.width = orderByDescendingWidth(children)[0].width;
			node.height = orderByDescendingWidth(children)[0].height;
		}
		/*
		node.X += modSum;
		modSum += node.Mod;

		foreach (var child in node.Children)
				CalculateFinalPositions(child, modSum);

		if (node.Children.Count == 0)
		{
				node.Width = node.X;
				node.Height = node.Y;
		}
		else
		{
				node.Width = node.Children.OrderByDescending(p => p.Width).First().Width;
				node.Height = node.Children.OrderByDescending(p => p.Height).First().Height;
		}
		*/

	} // end function

	//TODO: orders nodelist by width, returns ordered list
	function orderByDescendingWidth(children) {
		return children;
	}

	//https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/
	function calcInitNodeY(node) {
		//console.log("Calculating Initial Positions for node:", node.name);
		//console.log("lvlnode:",node);
		var children = getChildren(node.nodeid,nodes, treelinks);
		//console.log("children:", children);
		children.forEach(function(child) {
			//console.log("child:",child);
			calcInitNodeY(child);
		});


		var prevSibling = getPrevSibling(node);
		//console.log("prevSibling:", prevSibling);

		//if no children
		if (children.length == 0) {
			//console.log("no children for node:", node.name);
			//if there is a previous sibling
			if (prevSibling) {
				//console.log("has prevSibling");
				node.positionY = getPrevSibling(node).positionY + distY;
			} else { //if node is the first sibling/topmost node
				//console.log("no prevSiblings");
				node.positionY = 0;
			}
			//console.log("set positionY to:", node.positionY);
		} //end if no children
		else if (children.length == 1){
			//console.log("1 child code.. ");
			// if this is the first node in a set, set it's X value equal to it's child's X value
			/*if (node.IsLeftMost())
			{
					node.X = node.Children[0].X;
			}
			else
			{
					node.X = node.GetPreviousSibling().X + nodeSize + siblingDistance;
					node.Mod = node.X - node.Children[0].X;
			} */
			if (!prevSibling) {
				node.positionY = 0;
				//console.log("positionY set to ", node.positionY);
			} else {
				node.positionY = prevSibling.positionY + distY;
				//console.log("positionY set to ", node.positionY);
				node.mod = children[0].positionY;
				//console.log("mod changed to:", node.mod);
			}
		} //end if one child
		else { //if more than one child
			//console.log("more than one child of node:", node.name);
			/*var leftChild = node.GetLeftMostChild();
			var rightChild = node.GetRightMostChild();
			var mid = (leftChild.X + rightChild.X) / 2;

			if (node.IsLeftMost())
			{
					node.X = mid;
			}
			else
			{
					node.X = node.GetPreviousSibling().X + nodeSize + siblingDistance;
					node.Mod = node.X - mid;
			}*/
			//console.log("Several children code.. ", node);
			var leftChild = getLeftMostChild(node);
			var rightChild = getRightMostChild(node);
			var mid = (leftChild.positionY + rightChild.positionY) / 2;
			//console.log("leftmost child: ",leftChild);
			//console.log("rightmost child: ",rightChild);
			//console.log("mid: ",mid);

			//console.log("prevSibling:", prevSibling);

			if (!prevSibling) { //if node is leftmost(upmost)
				//console.log("no previous siblings for node:", node.name);
				node.positionY = mid;
				//console.log("positionY set to ", node.positionY);
			} else {
				node.positionY = prevSibling.positionY + distY;
				//console.log("positionY set to ", node.positionY);
				node.mod = node.positionY - mid;
				//console.log("set positionY to:", node.positionY);
				//console.log("set mod to:", node.mod);
			}
		} //end if several children

		/*if (node.Children.Count > 0 && !node.IsLeftMost())
		{
				// Since subtrees can overlap, check for conflicts and shift tree right if needed
				CheckForConflicts(node);
		}*/
		// Since subtrees can overlap, check for conflicts and shift tree right if needed
		if (children.length > 0 && prevSibling != null)
			checkForConflicts(node);

	} //end function

	function checkForConflicts(node) {
		//console.log("Checking for conflicts ....", node);
		var minDistance = distY;
		var shiftValue = 0;

		var nodeContour = {}; //create new dictionary
		nodeContour = getLeftContour(node, 0, nodeContour);

		var sibling = getLeftMostSibling(node);
		//console.log("LeftMostSibling:", sibling);

		while (sibling != null && sibling != node) {
			var siblingContour = {};
			siblingContour = getRightContour(sibling, 0, siblingContour);

			/*console.log("nodeContour:", nodeContour);
			console.log("siblingContour:", siblingContour);*/

			var siblingkeysmax = Object.keys(siblingContour).reduce(function(a, b){ return siblingContour[a] > siblingContour[b] ? a : b });
			var nodekeysmax = Object.keys(nodeContour).reduce(function(a, b){ return nodeContour[a] > nodeContour[b] ? a : b });

			/*console.log("siblingkeysmax:", siblingkeysmax);
			console.log("nodekeysmax:", nodekeysmax);
			console.log("init level:", node.positionX + distX);*/
			//for (var level = node.positionX + distX; level <= Math.min(siblingkeysmax, nodekeysmax); level++) {
			for (var level = node.positionX + distX; level <= siblingkeysmax; level++) {
				//console.log("level:", level);
				var distance = nodeContour[level] - siblingContour[level];
				if (distance + shiftValue < minDistance)
						shiftValue = minDistance - distance;
			}

			if (shiftValue > 0) {
					 node.positionY += shiftValue;
					 node.mod += shiftValue;

					 centerNodesBetween(node, sibling);

					 shiftValue = 0;
			 }

			 sibling = getNextSibling(sibling);

		} //end while
	} //end function

	function centerNodesBetween(leftNode, rightNode) {
		//var leftIndex = leftNode.Parent.Children.IndexOf(rightNode);
		var leftParent = getParent(leftNode.nodeid, nodes, treelinks);
		//var rightParent = getParent(rightNode.nodeid, nodes, treelinks);
		var leftParentChildren = getChildren(leftParent.nodeid, nodes, treelinks);
		//var rightParentChildren = getChildren(rightParent.nodeid, nodes, treelinks);
		var leftIndex = leftParentChildren.indexOf(rightNode);
		var rightIndex = leftParentChildren.indexOf(leftNode);

		var numNodesBetween = (rightIndex - leftIndex) - 1;

		if (numNodesBetween > 0) {
			var distanceBetweenNodes = (leftNode.positionY - rightNode.positionY) / (numNodesBetween + 1);
			var count = 1;
			for (var i = leftIndex + 1; i < rightIndex; i++){
				var middleNode = leftParentChildren[i];

				var desiredX = rightNode.positionY + (distanceBetweenNodes * count);
				var offset = desiredX - middleNode.positionY;
				middleNode.positionY += offset;
				middleNode.mod += offset;

				count++;
			}
			checkForConflicts(leftNode);
		}
	} //end function

	function checkAllChildrenOnScreen(node) {
		console.log("Checking all children on screen ....", node);
		var nodeContour = {}; //create new dictionary
		nodeContour = getLeftContour(node, 0, nodeContour);
		//console.log("nodeContour:", nodeContour);

		var shiftAmount = 0;

		for (var key in nodeContour) {
				if (nodeContour.hasOwnProperty(key)) {
					// do stuff
					if (nodeContour[key] + shiftAmount < 0)
						shiftAmount = (nodeContour[y] * -1);
				}
		}

		if (shiftAmount > 0) {
				node.positionY += shiftAmount;
				//console.log("positionY set to ", node.positionY);
				node.mod += shiftAmount;
		}
		/*var nodeContour = new Dictionary<int, float>();
		GetLeftContour(node, 0, ref nodeContour);
		float shiftAmount = 0;
		foreach (var y in nodeContour.Keys)
		{
				if (nodeContour[y] + shiftAmount < 0)
						shiftAmount = (nodeContour[y] * -1);
		}

		if (shiftAmount > 0)
		{
				node.X += shiftAmount;
				node.Mod += shiftAmount;
		}
		*/
	}

	function getLeftMostSibling(node) {

		var parentNode = getParent (node.nodeid, nodes, treelinks);
		return getLeftMostChild(parentNode);
	}

	function getLeftContour(node, modsum, values) {
	//  console.log("getLeftContour for node:", node);
		//if values has key node.positionX
		//console.log("     values.hasOwnProperty(",node.positionX, ") = ", values.hasOwnProperty(node.positionX));
		if (!values.hasOwnProperty(node.positionX)){
			//console.log("   no key..")
			//console.log("    node.positionY:",node.positionY, " + modsum:", modsum);
			values[node.positionX] = node.positionY + modsum;
		} else {
			/*console.log("    key exists, get minimim between");
			console.log("    values[node.positionX]:",values[node.positionX]);
			console.log("    and node.positionY:",node.positionY, " + modsum:", modsum);*/
			values[node.positionX] = Math.min(values[node.positionX], node.positionY + modsum);
		}

		//console.log("values after:", values);

		modsum += node.mod;

		var children = getChildren(node.nodeid,nodes, treelinks);

		children.forEach(function(child) {
			getLeftContour(child, modsum, values);
		});
		return values;
		/*if (!values.ContainsKey(node.Y))
				values.Add(node.Y, node.X + modSum);
		else
				values[node.Y] = Math.Min(values[node.Y], node.X + modSum);

		modSum += node.Mod;

		foreach (var child in node.Children)
		 {
				 GetLeftContour(child, modSum, ref values);
		 }
		*/
	} //end function

	function getRightContour(node, modsum, values) {
		//if values has key node.positionX
		if (!values.hasOwnProperty(node.positionX)){
			values[node.positionX] = node.positionY + modsum;
		} else {
			values[node.positionX] = Math.max(values[node.positionX], node.positionY + modsum);
		}

		//console.log("values after:", values);

		modsum += node.mod;

		var children = getChildren(node.nodeid,nodes, treelinks);

		children.forEach(function(child) {
			getRightContour(child, modsum, values);
		});
		return values;
	} //end function

	function getLeftMostChild(node) {
		//console.log("getLeftMostChild for node :", node);
		var children = getChildren(node.nodeid,nodes, treelinks);
		//console.log("first(leftmost) child :", children[0]);
		return children[0];
	}

	function getRightMostChild(node) {
		var children = getChildren(node.nodeid,nodes, treelinks);
		return children[children.length-1];
	}

	//get previous sibling
	function getPrevSibling(node) {
		//console.log("getPrevSibling function for node...", node.name);
		var parentNode = getParent (node.nodeid, nodes, treelinks);
		//console.log("   parentNode:", parentNode);
		if (parentNode) {
			var siblings =  getChildren (parentNode.nodeid, nodes, treelinks);
			//console.log("siblings:", siblings);
			var nodeindex = siblings.indexOf(node);
			if (nodeindex == 0) //it means that it is the topmost sibling
				return null;
			else {
				return siblings[nodeindex - 1];
			}
		}
	}

	function getNextSibling(node) {
		var parentNode = getParent (node.nodeid, nodes, treelinks);
		//console.log("parentNode:", parentNode);
		if (parentNode) {
			var siblings =  getChildren (parentNode.nodeid, nodes, treelinks);
			//console.log("siblings:", siblings);
			var nodeindex = siblings.indexOf(node);
			if (nodeindex == siblings.length-1) //it means that it is the rightmost/lowest sibling
				return null;
			else {
				return siblings[nodeindex + 1];
			}
		}
	}

	//takes an array of nodes as an input, returns the maximum level for that array
	function getMaxLevels(domainObj) {
		//console.log("maxlevel domainnodes:", domainObj.nodes);
		var nodes = domainObj.nodes;
		maxlevel = nodes[0].level;
		for (j = 0; j < nodes.length; j++) {
			if (nodes[j].level > maxlevel)
				maxlevel = nodes[j].level;
		}
		return maxlevel;
	}

	//MAIN FLOW STARTS HERE
	var domarray = getDomainArray();

	calcDomainPositionsX(domarray);

	//calcDomainPositionsY(domarray);

	var sortedDomarray = sortDomainArray(domarray);

	//console.log("sorted domarray:", sortedDomarray);

	calcNodePositionsY(sortedDomarray);

	//requirements to data:WHY?
	//-nodes sorted by level, starting from lowest levels
	//in the file, nodes have to be sorted by ids, because id is assigned sequentially

	//DOMAIN LABELS
	var hsep = 100; //horizontal separation between levels within one domain
	const domainLabelsY = -50;
	var domainLabelElem = svgGroup.selectAll("g domainLabels")
												.data(sortedDomarray)

	var domainLabelElemEnter = domainLabelElem.enter()

	domainLabelElemEnter.append("text")
	.attr("dx", function(d, i) {
			//return viewerWidth - hsep*(maxlevel - d.level);
			var domain = d.domain;
			var level = d.level;
			var domainstartX = d.startX;
			//console.log("Label Enter D:",d);
			//console.log("maxlevel + hsep:",d.maxlevel," + ", hsep);
			//d.positionX = viewerWidth - domainstartX - hsep*(domainmaxlevel - nodelevel);
			return domainstartX + d.maxlevel * hsep;
			//console.log("domainstartX:",  domainstartX, "posX:",  d.positionX );
	})
	.attr("dy", domainLabelsY)
	.attr("class", "domainLabels")
	.text(function(d){
			//return d.name + " pos:" + d.positionY + " spaceY:" + d.spaceY})
			return d.name })
	.attr("stroke", "black")
	.attr("stroke-width", 1)
	.style("text-transform", "uppercase")
	.style("font-size", 24);
	/*.attr("id", function(d, i) {
			return d.nodeid
	})
	.attr("class", "labels")
	.text(function(d){
			//console.log(d);
			//return d.name + " pos:" + d.positionY + " spaceY:" + d.spaceY})
			return d.name })
	.attr("stroke", "black")
	.attr("stroke-width", 1);*/



	var elem = svgGroup.selectAll("g circles")
			.data(nodes)

	/*Create and place the "blocks" containing the circle and the text */
	var elemEnter = elem.enter()
			//.attr("transform", function(d){return "translate("+d.x+",80)"})

	function getNodeIndexByName(nodename) {
		//console.log("getNodeIndexByName function...");
		//console.log("nodes:", nodes);
		//console.log("nodename:", nodename);
		for (var j = 0; j < nodes.length; j++) {
			//console.log("domainelement.nodes[j].id:", domainelement.nodes[j].nodeid, "nodeid:", nodeid);
			if (nodename == nodes[j].name) {
				//iterate within that domain and count how many nodes are there at that level
					//console.log("return nodeindex:", j);
					return j;
			}
		}
//      return null;
	}

	function getChildren(nodeindex, nodes, treelinks) {
	//Given a node index, returns a list of children for this node
			//go through each link
				//if link.source == nodeindex
					//check level of nodes[link.target]
					//- if level is lower than current node (nodes[nodeindex]), then add to the children list
				//if link.target == nodeindex
					//check level of nodes[link.source] - if level is lower than current node (nodes[nodeindex]), then add to the children list
			children = [];
			//console.log("current node", nodes[nodeindex].name);
			//console.log("treelinks:", treelinks);
			for (var j = 0; j < treelinks.length; j++) {
				link = treelinks[j];
				//console.log(link);
				source = getNodeIndexByName(link.source);
				target = getNodeIndexByName(link.target);
				if (nodes[target].domain == nodes[nodeindex].domain && nodes[source].domain == nodes[nodeindex].domain) {
					if (source == nodeindex) {
						//console.log(nodeindex,nodes[nodeindex].name, nodes[target].name, nodes[target].level);
						if (nodes[target].level > nodes[nodeindex].level)
							//put into children list
							children.push(nodes[target]);
					}//if
					if (target == nodeindex) {
						if (nodes[source].level > nodes[nodeindex].level)
							//put into children list
							children.push(nodes[source]);
					}//if
				}
			}//for loop
			//console.log("number of children", children.length);
			return children
	}//function

	function getParent(nodeindex, nodes, treelinks) {
	//  console.log("treelinks:", treelinks);
//      console.log("nodeindex:", nodeindex);
		var parent = null;
		for (j = 0; j < treelinks.length; j++) {
			link = treelinks[j];
			source = getNodeIndexByName(link.source);
			target = getNodeIndexByName(link.target);
			if (source == nodeindex) {
				//console.log(link);
				//console.log(nodeindex,nodes[nodeindex].name, nodes[target].name, nodes[target].level);
				if (nodes[target].level < nodes[nodeindex].level && nodes[target].domain == nodes[nodeindex].domain)
					//put into children list
					parent = nodes[target];
					//console.log("node: ", nodes[nodeindex], "target: ", nodes[target]);
			}//if
			if (target == nodeindex) {
				//console.log(link);
				//console.log(nodeindex,nodes[nodeindex].name, nodes[source].name, nodes[source].level);
				if (nodes[source].level < nodes[nodeindex].level && nodes[source].domain == nodes[nodeindex].domain)
					//put into children list
					parent = nodes[source];
					//console.log("node: ", nodes[nodeindex], "source: ", nodes[source]);
			}//if
		}//for loop

		//TODO: Make sure that parent belongs to the same domain as a child
		return parent
	}

	function getAvgPositionY(children) {
		sum = 0;
		//for each child in children
		for (j = 0; j < children.length; j++) {
			child = children[j];
			//console.log("child: ", child.name, "posY:", child.positionY);
			sum = sum + child.positionY;
		}
		avg = sum / children.length;
		//console.log("average posY: ", avg);
		return avg
	}

	function getDomainLevelSize(domain,level,domarray) {
		var result = 0;
		for (var j = 0; j < domarray.length; j++) {
			if (domain == domarray[j].name) {
				//iterate within that domain and count how many nodes are there at that level
				for (var k = 0; k < domarray[j].nodes.length; k++) {
					if (level == domarray[j].nodes[k].level) {
						result = result + 1;
					}
				}
			}
		}
		//console.log("domain:", domain, "level:", level, "number of nodes: ", result);
		return result;
	}

	function getDomainElement(domain,domarray) {
		for (var j = 0; j < domarray.length; j++) {
			if (domain == domarray[j].name) {
				//iterate within that domain and count how many nodes are there at that level
					//console.log("return:", domarray[j]);
					return domarray[j];
			}
		}
	} //end function

	//given domain element and needed nodeID, returns index for that nodeID in the domain.nodes array
	function getNodeIndex(nodeid,domainelement) {
		//console.log("domainelement.nodes:", domainelement.nodes);
		for (var j = 0; j < domainelement.nodes.length; j++) {
			//console.log("domainelement.nodes[j].id:", domainelement.nodes[j].nodeid, "nodeid:", nodeid);
			if (nodeid == domainelement.nodes[j].nodeid) {
				//iterate within that domain and count how many nodes are there at that level
					//console.log("return nodeindex:", j);
					return j;
			}
		}
	} //end function

	//console.log(nodes);
	maxlevel = 5;
	var lvl1counter = 0;


			//http://bl.ocks.org/timpulver/d3fefb4fac2510cf81a8
		function clickcancel() {
				var event = d3.dispatch('click', 'dblclick');

				function cc(selection) {
					console.log(selection);
					var down,
					tolerance = 5,
					last,
					wait = null;
					// euclidean distance
					function dist(a, b) {
						return Math.sqrt(Math.pow(a[0] - b[0], 2), Math.pow(a[1] - b[1], 2));
					}
					selection.on('mousedown', function() {
						down = d3.mouse(document.body);
						last = +new Date();
					});
					selection.on('mouseup', function() {
						if (dist(down, d3.mouse(document.body)) > tolerance) {
							return;
						} else {
							if (wait) {
								window.clearTimeout(wait);
								wait = null;
								event.dblclick(d3.event);
							} else {
								wait = window.setTimeout((function(e) {
									return function() {
										event.click(e);
										wait = null;
									};
								})(d3.event), 300);
							}
						}
					});
				};
				return d3.rebind(cc, event, 'on');
		}

		var cc = clickcancel();

		var circle = elemEnter.append("circle")
		.attr("class", "nodes")
		.attr("id", function(d, i) {
			return i
		})
		.attr("cx", function(d, i) {
			//DOMAINS - WORK HERE
			//console.log("posX:",viewerWidth, hsep*d.level);
			//d.positionX = viewerWidth - hsep*(maxlevel - d.level);
			nodedomain = d.domain;
			nodelevel = d.level;
			domainstartX = getDomainElement(nodedomain,domarray).startX;
			domainmaxlevel = getDomainElement(nodedomain,domarray).maxlevel;
			//d.positionX = viewerWidth - domainstartX - hsep*(domainmaxlevel - nodelevel);

			//console.log("domainstartX:",  domainstartX, "posX:",  d.positionX );
			return d.positionX;
		})
		.attr("cy", function(d, i) {
			d.children = getChildren(i, nodes, treelinks);
			d.parent = getParent(i, nodes, treelinks);
			return d.positionY;

		})
		//.on("mouseover", handleMouseOver) //http://bl.ocks.org/WilliamQLiu/76ae20060e19bf42d774
		//.on("mouseout", handleMouseOut)
		.call(cc)
		//.on("dbclick",handleDoubleClick)
		//.on("click", handleMouseClick)
		.attr("r", radius)
		.attr("fill", "lightsteelblue")
		.attr("stroke", "steelblue")
		.attr("stroke-width", function(d) {
			return d/2;
		})
		;

		cc.on('click', handleMouseClick); //in this case not data, but mouseevent is passed
		cc.on('dblclick', handleDoubleClick); //in this case not data, but mouseevent is passed

		//http://bl.ocks.org/WilliamQLiu/76ae20060e19bf42d774
		// Create Event Handlers for mouse
		function handleDoubleClick(d, i) {
			console.log("double click event");
			alert("node was double clicked");
		}

		function handleMouseOver(d, i) {  // Add interactivity

					//get nodeid = i, index in the nodes list from json
					//console.log(d, "index:", i, "tracingDictFull:", tracingDictFull[i]);

					//find all nodes that share traces with the current node
					curtrace = getNodeIDsFromTraceArray(tracingDictFull[i], nodes);
					//console.log("curtrace:", curtrace, "indexOf:", curtrace.indexOf("26"));
					//var fulltrace = getFullTracingDict([13,47]);

					//find nodes from trace, highlight them
					svgGroup.selectAll(".nodes")
									.filter(function(d,i){
										//return d3.select(this).attr('id') > 4;
										//console.log("selected:", d);
										currentID = d3.select(this).attr('id');
										//console.log("currentID:", currentID);
										return curtrace.indexOf(parseInt(currentID)) != -1; //add to selection only if the id of the current node is in the tracelist for the clicked node
										})
									.attr({
										fill: "orange"
						//r: radius * 2
					});

					//find edges where source and target are both in tracingDict[i]
					svgGroup.selectAll(".edges")
									.filter(function(d,i){
										//console.log("filtering edges...");
										edgeSource = d3.select(this).attr('source');
										edgeTarget = d3.select(this).attr('target');
										return (curtrace.indexOf(parseInt(edgeSource)) != -1 && curtrace.indexOf(parseInt(edgeTarget)) != -1);
									})
									.attr({
									stroke: "orange"
					});

					//IMPLEMENT DOMAINS, ENABLE TRACEBILITY BETWEEN DOMAINS

				}

	function handleMouseOut(d, i) {
			// Use D3 to select element, change color back to normal
			/*d3.select(this).attr({
				fill: "lightsteelblue",
				r: radius
			});*/ //THIS IS FOR ONE, CURRENT ELEMENT ONLY
			//find nodes from trace, highlight them
			svgGroup.selectAll(".nodes").attr({
				fill: "lightsteelblue",
				r: radius
			});

			svgGroup.selectAll(".edges").attr({
				stroke: "lightsteelblue"
			});

			// Select text by id and then remove
			//d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
		}

	//Collapse on click
	//http://bl.ocks.org/d3noob/8375092
	//when collapse - store children before collapsing to _children field
	//when expand - bring back children from _children
	function handleMouseClick(d, i) {

	/* THIS IS FROM THE ORIGINAL VERSION, REMOVED FOR MTURK PURPOSES
	ddata = d3.select(d.srcElement).data()[0];
	console.log("clicked object:", ddata);
	if (!ddata.collapsed)
		collapse(ddata);
	else
		decollapse(ddata);
	*/
	var clickedElem = d3.select(d.srcElement);
	var clickedElemData = clickedElem.data()[0];
	console.log("clicked object:", clickedElemData);

	if (clickedElem.attr("fill") == "orange") { //if already clicked
		//repaint back
		clickedElem.attr({fill: "lightsteelblue"});
		//remove from the list of selected nodes
		var index = clickedElemList.indexOf(clickedElem);
		if (index > -1) {
			clickedElemList.splice(index, 1);
		}
	} else {
		//paint as highlighted
		clickedElem.attr({fill: "orange"});
		//add to the list of selected nodes
		clickedElemList.push(clickedElem);
	}

	if (taskType >= 4) {
		//return the whole list
		console.log("clicked list:", clickedElemList);
	} else {
		//return the last element, if any
		if (clickedElemList.length > 0) {
			console.log("clicked list last elem:", clickedElemList[clickedElemList.length - 1].data()[0]);
		} else {
			console.log("no items in clicked list");
		}
	}

} //end function handleMouseClick

function collapse(nodeSelection) {
	//console.log("current nodeSelection: ", nodeSelection);
		if (nodeSelection.children) {
			nodeSelection._children = nodeSelection.children;
			nodeSelection._children.forEach(collapse);
			nodeSelection._children.forEach(hideInParent);
			nodeSelection.children = null;
			nodeSelection.collapsed = true;
		}
}

function decollapse(nodeSelection) {
	//console.log("decollapse");
	//console.log("current nodeSelection: ", nodeSelection, "collapsed", nodeSelection.collapsed);
		if (nodeSelection._children) {
			nodeSelection.children = nodeSelection._children;
			nodeSelection.children.forEach(decollapse);
			nodeSelection.children.forEach(setCoordsToPrevPos);
			nodeSelection._children = null;
			nodeSelection.collapsed = false;
		}
}

function setCoordsToPrevPos(nodeSelection) {
	console.log("set coordinates to previous position");

	//bring back nodes to the last saved position
	var currentNodeSelection =  svgGroup.selectAll(".nodes")
					.filter(function(d,i){
						return d.nodeid == nodeSelection.nodeid;
					})

	lastPosX = currentNodeSelection.attr("lastPosX");
	lastPosY = currentNodeSelection.attr("lastPosY");

	console.log("lastPosX:", lastPosX);
	console.log("lastPosY:", lastPosY);

	currentNodeSelection.attr("fill", "lightsteelblue")
											.attr("cx", lastPosX)
											.attr("cy", lastPosY)
											.transition();

	currentNodeSelection.transition()
											.attr("visibility", "visible");

	var labelSelection = svgGroup.selectAll(".labels")
																				.filter(function(d,i){
																				return d.nodeid == nodeSelection.nodeid;
																				//console.log("currentID:", currentID, " is in children:", openChildrenIDs.indexOf(currentID.toString()) );
																		})
																			 .attr("visibility", "visible");

	//hide edges - choose all paths where "target" attribute is within openChildrenIDs
	 var edgeChildrenSelection = svgGroup.selectAll(".edges")
																			 .filter(function(d,i){
																					 currentTarget = d3.select(this).attr('target');
																					 //console.log("currentTarget:", currentTarget, " is in children:", openChildrenIDs.indexOf(currentTarget.toString()) );
																					 return currentTarget == nodeSelection.nodeid;
																			 })
																			 .attr("visibility", "visible");

}

function hideInParent(nodeSelection) {
	//
	//console.log("hideInParent", nodeSelection);
	//get parent nodes coordinates
	var parentSelection = svgGroup.selectAll(".nodes")
					.filter(function(d,i){
						currentID = parseInt(d3.select(this).attr('id'));
						//console.log("currentID:", currentID, " parentID:", nodeSelection.parent.nodeid);
						return currentID == nodeSelection.parent.nodeid;
					});

	//console.log("parentSelection: ",parentSelection);
	parentCX = parentSelection.attr("cx");
	parentCY = parentSelection.attr("cy");

	//set their coordinates to parent coordinates
	var currentNodeSelection =  svgGroup.selectAll(".nodes")
					.filter(function(d,i){
						return d.nodeid == nodeSelection.nodeid;
					})

	console.log("currentNodeSelection: ",currentNodeSelection);

	//save last position
	currentPosX = currentNodeSelection.attr("cx");
	currentPosY = currentNodeSelection.attr("cy");

	console.log("currentPosX: ",currentPosX);
	console.log("currentPosY: ",currentPosY);

	/*currentNodeSelection.transition()
											.attr("cx", parentCX)
											.attr("cy", parentCY)
											.attr("lastPosX", currentPosX)
											.attr("lastPosY", currentPosY); */

	currentNodeSelection.attr("lastPosX", currentPosX)
	.attr("lastPosY", currentPosY)
	.transition()
	.attr("cx", parentCX)
	.attr("cy", parentCY);


	currentNodeSelection.transition()
										.delay(100)
										.attr("visibility", "hidden");
	//                    .transition();

 //hide labels
 var labelSelection = svgGroup.selectAll(".labels")
																			 .filter(function(d,i){
																			 return d.nodeid == nodeSelection.nodeid;
																			 //console.log("currentID:", currentID, " is in children:", openChildrenIDs.indexOf(currentID.toString()) );
																	 })
																			.attr("visibility", "hidden");

 //hide edges - choose all paths where "target" attribute is within openChildrenIDs
	var edgeChildrenSelection = svgGroup.selectAll(".edges")
																			.filter(function(d,i){
																					currentTarget = d3.select(this).attr('target');
																					//console.log("currentTarget:", currentTarget, " is in children:", openChildrenIDs.indexOf(currentTarget.toString()) );
																					return currentTarget == nodeSelection.nodeid;
																					//return currentTarget == 63;
																			})
																			.attr("visibility", "hidden");
}

	//DRAWING EDGES
		//http://bl.ocks.org/milkbread/5902470
		links.forEach(function(link){
				//console.log(link, link.source, nodes[link.source].name, nodes[link.source].positionX);
				var lineData = [ { "x": 1,   "y": 5},  { "x": 20,  "y": 20}];//arbitrary
				lineData[0].x = nodes[getNodeIndexByName(link.source)].positionX
				lineData[0].y = nodes[getNodeIndexByName(link.source)].positionY
				lineData[1].x = nodes[getNodeIndexByName(link.target)].positionX
				lineData[1].y = nodes[getNodeIndexByName(link.target)].positionY
				//console.log("lineData", lineData);

			 var diagonal = d3.svg.diagonal()
			 .projection(function(d) { return [d.y, d.x]; });

//https://github.com/d3/d3-shape/issues/27
			 function linkHorizontal(d) {
				 return "M" + d[0].x + "," + d[0].y
		+ "C" + d[0].x +  "," + (d[0].y + d[1].y) / 2
		+ " " + d[1].x + "," + (d[0].y + d[1].y) / 2
		+ " " + d[1].x + "," + d[1].y;
			}

			function linkVertical(d) {
				return "M" + d[0].x + "," + d[0].y
						+ "C" + (d[0].x + d[1].x) / 2 + "," + d[0].y
						+ " " + (d[0].x + d[1].x) / 2 + "," + d[1].y
						+ " " + d[1].x + "," + d[1].y;
			}

			 var lineGraph = elemEnter.append("path")
																	 .attr('d', linkVertical(lineData)) //THIS IS BEING TESTED
																	 //.attr("id", "source:" + link.source + "," + "target:" + link.target)
																	 .attr("source", getNodeIndexByName(link.source))
																	 .attr("target", getNodeIndexByName(link.target))
																	 .attr("class", "edges")
																	 .attr("stroke", "lightsteelblue")
																	 .attr("stroke-width", 1)
																	 .attr("fill", "none");

		}); //foreach

		//LABELS
		//https://stackoverflow.com/questions/13615381/d3-add-text-to-circle
		/* Create the text for each block */
		elemEnter.append("text")
		.attr("dx", function(d, i) {
				//console.log("Label Enter D:",d);
				//return viewerWidth - hsep*(maxlevel - d.level);
				nodedomain = d.domain;
				nodelevel = d.level;
				domainstartX = getDomainElement(nodedomain,domarray).startX;
				domainmaxlevel = getDomainElement(nodedomain,domarray).maxlevel;
				//d.positionX = viewerWidth - domainstartX - hsep*(domainmaxlevel - nodelevel);
				//console.log("domainstartX:",  domainstartX, "posX:",  d.positionX );
				return d.positionX + 5;
		})
		.attr("dy", function(d, i) {
				return d.positionY;
		})
		.attr("id", function(d, i) {
				return d.nodeid
		})
		.attr("class", "labels")
		.text(function(d){
				//console.log(d);
				//return d.name + " pos:" + d.positionY + " spaceY:" + d.spaceY})
				return d.name + ":" + d.nodeid})
		.attr("stroke", "black")
		.attr("stroke-width", 1);
}
</script>




</html>
