<!DOCTYPE html>
<!--
The code below is mostly borrowed from https://bl.ocks.org/mbostock/1341021

neigbourhoods with high income are also the ones that have Danes

TODO load json data, connect neigbourhoods to plots
-->

<meta charset="utf-8">
<style>

svg {
  font: 10px sans-serif;
}

.background path {
  fill: none;
  stroke: #ddd;
  shape-rendering: crispEdges;
}

.foreground path {
  fill: none;
  stroke: steelblue;
}

.brush .extent {
  fill-opacity: .3;
  stroke: #fff;
  shape-rendering: crispEdges;
}

.axis line,
.axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis text {
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

.nonselected {
  fill: #4078c0;
  fill-opacity: 0.2;
  stroke-width: 0.7;
  stroke: #4078c0;
  stroke-opacity: 0.5;
  /*.style("fill", "#4078c0")
  .style("fill-opacity", "0.2")
  .style("stroke-width", "0.7")
  .style("stroke", "#4078c0")
  .style("stroke-opacity", "0.5")*/
}

.selected {
  fill: orange;
  fill-opacity: 0.2;
  stroke-width: 0.7;
  stroke: #4078c0;
  stroke-opacity: 0.5;
}

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/d3.geo.projection.v0.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script>

var margin = {top: 30, right: 10, bottom: 10, left: 10},
    width = 1800 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom;

var x = d3.scale.ordinal().rangePoints([0, width], 1),
    y = {};

var line = d3.svg.line(),
    axis = d3.svg.axis().orient("left"),
    background,
    foreground;

var selectedData  = [];

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var svg2 = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


d3.csv("samlede_socio_data_kbh.csv", function(error, cars) {

  // Extract the list of dimensions and create a scale for each.
  x.domain(dimensions = d3.keys(cars[0]).filter(function(d) {
    //dont show name and year columns
    return d != "name" && d != "year" && (y[d] = d3.scale.linear()
        .domain(d3.extent(cars, function(p) { return +p[d]; }))
        .range([height, 0]));
  }));

  socio = filterByYear(cars, "2013");

  // Add grey background lines for context.
  background = svg.append("g")
      .attr("class", "background")
    .selectAll("path")
      .data(socio)
    .enter().append("path")
      .attr("d", path);

  // Add blue foreground lines for focus.
  foreground = svg.append("g")
      .attr("class", "foreground")
    .selectAll("path")
      .data(socio)
    .enter().append("path")
      .attr("d", path);

  // Add a group element for each dimension.
  var g = svg.selectAll(".dimension")
      .data(dimensions)
    .enter().append("g")
      .attr("class", "dimension")
      .attr("transform", function(d) { return "translate(" + x(d) + ")"; });

  // Add an axis and title.
  g.append("g")
      .attr("class", "axis")
      .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
    .append("text")
      .style("text-anchor", "middle")
      .attr("y", -9)
      .text(function(d) { return d; });

  // Add and store a brush for each axis.
  g.append("g")
      .attr("class", "brush")
      .each(function(d) { d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brush", brush)); })
    .selectAll("rect")
      .attr("x", -8)
      .attr("width", 16);
});

d3.json("http://wfs-kbhkort.kk.dk/k101/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=k101:samlede_socio_data_kbh&outputFormat=json&SRSNAME=EPSG:4326&maxfeatures=1000", function(error, json) {
  //Bind data and create one path per GeoJSON feature

  var center = d3.geo.centroid(json);
        var scale  = 120000;
        var offset = [width/2, height/2.5];

        var projection = d3.geo.mercator().scale(scale).center([12.554322562596862,55.688013184009826])
                .translate(offset);

      //Define path generator, using the Albers USA projection
      var geopath = d3.geo.path()
      .projection(projection);

  console.log(json.features);
  svg2.selectAll("path")
  .data(json.features)
  .enter()
  .append("path")
  .attr("d", geopath)
  .attr("class", "nonselected")
  /*.style("fill", "#4078c0")
  .style("fill-opacity", "0.2")
  .style("stroke-width", "0.7")
  .style("stroke", "#4078c0")
  .style("stroke-opacity", "0.5")*/
  .on("click", function(d) {
    highlightPath(d.properties.rodenavn);
  });
});

function highlightPath(rodenavn) {
  //console.log(rodenavn);
  //from svg1 select paths with those rodenavns
  svg.selectAll("path").filter(function(d) {
    console.log(d.name);
    return d.name == rodenavn;
  })
  .attr("fill","red");
}

// Returns the path for a given data point.
function path(d) {
  return line(dimensions.map(function(p) { return [x(p), y[p](d[p])]; }));
}

function filterByYear(data, year) {
  //console.log(data);
  //console.log(year);
  var result = [];
  for (var i = 0; i < data.length; i++) {
    if (data[i].year === year) {
        //console.log(data[i]);
        result.push(data[i]);
    }
  }
  console.log(result);
  return result;
}

// Handles a brush event, toggling the display of foreground lines.
function brush() {
  //reset all paths to default color - DOES NOT WORK
  svg2.selectAll("path").
  attr("class","nonselected");

  var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
      extents = actives.map(function(p) { return y[p].brush.extent(); });
  foreground.style("display", function(d) {
    //console.log(actives);
    return actives.every(function(p, i) {
      if (extents[i][0] <= d[p] && d[p] <= extents[i][1]) {
          //push brushed data to a separate array to filter districts later
          selectedData.push(d);
          //console.log(d); //print selected data
      }
      return extents[i][0] <= d[p] && d[p] <= extents[i][1];
    }) ? null : "none";
  });

  function extractRodenavns(data) {
    var result = [];
    console.log(data.length);
    for (var i = 0; i < data.length; i++) {
      //console.log(data[i].name);
      //if not already in the array, add to it
      if (result.indexOf(data[i].name) == -1) {
        //console.log(data[i].name);
        result.push(data[i].name);
      }
    }
    console.log(result.length);
    return result;
  }

  //console.log(d3.select(this));
  //select all paths from svg2 and color them differently
  console.log("select all paths from svg2 and color them differently");

//get list of selected foregrounds
  console.log(selectedData);

  //extract unique rodenavns from them
  var rodenavns = extractRodenavns(selectedData);

  //filter paths of svg2 by rodenavns
  var districts = svg2.selectAll("path")
    .filter(function(d) {
      //return d.properties.rodenavn === "Ryparkens";
      for (var i = 0; i < rodenavns.length; i++) {
        if (d.properties.rodenavn === rodenavns[i]) {
            return d.properties.rodenavn;
        }
      }
    })
  .attr("class", "selected");

  console.log("districts");
  console.log(districts);
}


</script>
